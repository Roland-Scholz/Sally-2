;********************************************************
;*							*
;*							*
;********************************************************
;
;
	SALLYDEBUG = 1
;
;
;
INIT:		DI
		XOR	A
INIT1:		DEC	A
		JR	NZ,INIT1				;DO NOTHING FOR 1 MILLISECOND

		LD	HL,INITAB
		LD	B,ITBLEN/2				;SEND INITIAL POOP TO PROGRAMABLE I/O'S
INIT2:		LD	C,(HL)
		INC	HL
		OUTI
		JR	NZ,INIT2
;
;	PERFORM READ/WRITE TEST OF TOP 4K RAM
;
RAMTST:		LD	HL,MONITOR
		LD	A,1
RTST1:		LD	B,16
RTST2:		LD	(HL),A					;WRITE TEST BYTE INTO MONITOR/GLOBALS
		RLCA						;ROTATE BIT PATTERN IN A
		INC	L					;BUMP L TO DO INNER LOOP 256 TIMES
		JR	NZ,RTST2
		INC	H
		DJNZ	RTST2					;REPEAT 16 TIMES FOR 4096 BYTES

		LD	C,16
RTST3:		DEC	HL
		RRCA
		CP	(HL)					;VERIFY THAT TEST PATTERN IS WRITTEN
		JR	NZ,$					;STICK FOREVER IF MONITOR RAM FAILURE
		DJNZ	RTST3
		DEC	C
		JR	NZ,RTST3

		ADD	A,A
		JR	NZ,RTST1				;DO 8 PASSES OVER MEMORY
;
;	NOW COPY MONITOR AND VARIABLES TO HIGH RAM
;
		LD	HL,MONCOPY
		LD	DE,MONITOR
		LD	BC,MONSIZE
		LDIR						;COPY RESIDENT CODE INTO RAM

		LD	HL,VARCOPY
		LD	DE,glbvars
		LD	BC,glbsize
		LDIR						;INITIALIZE GLOBAL VARIABLES
		XOR	A
ZEROS:		LD	(DE),A
		INC	E
		JR	NZ,ZEROS				;FILL REST OF SCRATCHPAD WITH ZEROS

IF SALLYBUILD			
		LD	HL, 00000h				; source
		LD	DE, 08000h				; dest
		LD	BC, 02000h
		LDIR
		LD	HL, code8000
		SET	7, H
		JP	(HL)
code8000:
		LD	A, 1
		OUT	(BANKSW), A
		LD	HL, 08000h
		LD	DE, 00000h
		LD	BC, 02000h
		LDIR
		JP	code0000
code0000:
ENDIF	;SALLYBUILD


;
;	ESTABLISH STACK AND INTERRUPT VECTOR BASE
;
		LD	SP,KEYBUF+16				;TEMP PLACE FOR STACK
		LD	A,HIGH RAM			
		LD	I,A					;POINT I REGISTER TO VECTOR TABLE
		IM	2					;SELECT VECTORED INTERRUPTS
;			
;step 5 times in and then out to trk00.  
;set bit 6 for each online floppy in ff5eh percom block (16 bytes, byte 8 bit 6)
;
REST:		LD	A, FBS+DRVSEL4+DRVSEL3+DRVSEL2+DRVSEL1	;INITIAL DRIVE PATTERN (ALL SELECTED) - select drive 1-4, Motor off, side 0, B/S=1, DD
		OUT	(LATCH), A
		LD	D,A					;KEEP PATTERN IN D (d = 4fh)
		LD	B,5					;step 5 times
REST1:		LD	A,STEPIN+NOWAITMTR+STEPRATE		;4b: 4 = step-in, b = NOWAITMTR+STEPRATE3

IF WD1772
		CALL	SalyCMDOUT				;write A to FDC command and wait
ELSE			
		CALL	TYP1CMD					;STEP IN 5 TIMES AS PRECAUTION FOR
ENDIF	;WD1772			
			
		DJNZ	REST1					; DRIVES THAT GET BEHIND TK0 SENSOR
		LD	B,100					;DO 100 STEPS TOWARD TRACK ZERO (support 100 track drives)
REST2:		LD	A,D			
		OUT	(LATCH),A				;ISSUE SELECTS AND PAUSE A BIT
		EX	(SP),HL
		EX	(SP),HL
		LD	A,STEPOUT+NOWAITMTR+STEPRATE		;6b: 6 = step-out, b = NOWAITMTR+STEPRATE3

IF WD1772
		CALL	SalyCMDOUT				;write A to FDC command and wait
ELSE			
		CALL	TYP1CMD					;ISSUE STEP OUT COMMAND TO DRIVES
ENDIF	;WD1772			
			
		LD	E,DRVSEL1				;PREPARE TO TEST TK0 INDICATORS
REST3:		LD	A,E			
		OR	FBS			
		OUT	(LATCH),A				;SELECT ONE DRIVE AT A TIME
		EX	(SP),HL					;Use this benign operation pair
		EX	(SP),HL					;to wait 38 T-states

IF WD1772
		IN	A, (STSREG)
ELSE
		CALL	FORCE					;FORCE INTERRUPT TO SET TYPE 1 STATUS
ENDIF	;WD1772			
			
		BIT	2, A			
		JR	Z,REST3A				;JUMP IF TRACK ZERO NOT INDICATED
		LD	A,E			
		CPL			
		AND	D					;ELSE RESET SELECT BIT FOR DRIVE IN D
		LD	D,A			
REST3A:		SLA	E					;ADVANCE SELECT BIT
		BIT	4,E			
		JR	Z,REST3					;DO SAME FOR ALL 4 DRIVES
		DJNZ	REST2					;THEN REPEAT STEP OUT 100 TIMES
			
IF WD1772			
		LD	A, FDCRESET+FBS				;reset FDC and deselct
		OUT	(LATCH), A			
		LD	A, FBS					;reset FDC and deselct
		OUT	(LATCH), A			
ELSE			
		call	shutdown				;unload the heads and deselect the drives
ENDIF	;WD1772

	IF SALLYRS = 1
		xor	a
		ld	b, a
		ld	hl, drivedata
cleardrivedata:	ld	(hl), a
		inc	hl
		djnz	cleardrivedata
	ENDIF

	IF SALLYRS = 0
		LD	HL, DMATRIX+DSKBITS
		LD	BC, 16
	ELSE
		LD	HL, drivedata + DSKBITS
		LD	BC, 64
	ENDIF
		LD	A, 4					;PREP TO SET FLAGS FOR DRIVES PRESENT
REST4:		RR	D			
		JR	C,REST4A				;JUMP IF DRIVE(N) NOT AT TRACK ZERO
		SET	PRESENT,(HL)				;ELSE SET BIT IN ARRAY(HL)
REST4A:		ADD	HL,BC			
		DEC	 A			
		JR	NZ,REST4				;DO FOR ALL 4 DRIVES
;			

		LD	SP, IOBUFF				;NEW PLACE FOR STACK

IF SALLYBUILD
;--------------------------------------------------
; firmware patch
;--------------------------------------------------
		LD	A, SIONORMAL				;init Pokey-divisor
		LD	(pokeydiv), A
		
		LD	A, 2
		LD	(direct), A
		
		LD	HL, 0ffffh				;reset drive / track buffer
		LD	(drive), HL

	IF SALLYRS = 0
		LD	HL, DISKTAB+2
		LD	DE, dsktb+3
		LD	BC, 3*7
		LDIR

		LD	HL, 8
		LD	(dsktb),HL
		LD	A, '?'
		LD	(dsktb+2), A
		EX	DE, HL

		LD	A, getspeed & 255
		LD	(HL), A
		INC	HL
		LD	A, getspeed / 256
		LD	(HL), A
		INC	HL

		LD	HL, dsktb
		LD	(SalyDISKID), HL
		LD	(SalyDISKID+2), HL
		LD	(SalyDISKID+4), HL
		LD	(SalyDISKID+6), HL

	ENDIF
		LD	A, 0c3h					;'JP' instruction
		LD	(XMITBUF), A
		LD	(RXBLOCK), A
		LD	(CMDWAIT), A
		LD	(SalyLOGN1), A
		LD	(SalyDISKWRT1), A
		LD	(SalyDISKRD1), A
;		LD	(DISK4),A

		LD	HL, xmitbuffn
		LD	(XMITBUF+1), HL
		LD	HL, rxblck
		LD	(RXBLOCK+1), HL
		LD	HL, cmdwaitfn
		LD	(CMDWAIT+1), HL
		LD	HL, SalyLogon
		LD	(SalyLOGN1+1), HL
		LD	HL, dskreadfn
		LD	(SalyDISKRD3+1), HL
		LD	HL, dskrd1
		LD	(SalyDISKRD1+1), HL
		LD	HL, dskwrite
		LD	(SalyDISKWRT3+1), HL
		LD	HL, dwrt
		LD	(SalyDISKWRT1+1), HL
;		LD	HL, diskiodebug
;		LD	(DISK4+1),HL


ENDIF	;SALLYBUILD

		JP	EMULATOR				;GO INITIALIZE FOR ATARI OR CP/M


IF SALLYBUILD

SalyLogon:
		LD	(RWMAX),A				;DO LESS RETRIES IN ATARI MODE

		LD	A, 0c3h					;'JP' instruction
		LD	(SEL4), A
		LD	HL, SalySEL4
		LD	(SEL4+1), HL
	IF WD1772
		LD	HL, SalyShutdn
		LD	(SHUTDOWN+1), HL
	ENDIF
		JP	SalyLOGN2

	IF WD1772
	
SalyShutdn:
		CALL	SalyResetFDC
		LD	A, CTC_D6_MODE_TIM + CTC_D2_TCNEXT + CTC_D1_SW_RST + CTC_D0_CONTROL
		OUT	(CTC1), A				;SOFWARE RESET CTC1
		LD	A, 1					;TIME CONSTANT OF 1 - 4uS pulses (1/4Mhz)*16
		OUT	(CTC1), A
		RET
	ENDIF
;
;
;
SalySEL4:
		BIT	6, B					;8" found?
		JR	Z, SalySEL4ex				;yes, do nothing

		PUSH	BC					;save registers
		PUSH	DE
		PUSH	HL
		PUSH	IX

		LD	A, B					;switch HD on
		RES	6, A
		OUT	(LATCH), A

		PUSH	IX					;load HL with IX
		POP	HL
		LD	DE, dcb
		LD	BC, 9
		LDIR						;copy dcb
			
		LD	IX, dcb
		LD	HL, idambuf
		LD	(dcb + DSKPTR), HL
		LD	HL, 6
		LD	(dcb + DSKAUX), HL
		LD	A, RIDCMD+4				;read address + settle delay
		LD	(CMDBYT), A
		LD	A, 018h					;substitute JR	Z,xx by JR xx
		LD	(DISK3 + 031h), A
		LD	B, 3
SalySEL4A:
		PUSH	BC
		CALL	SalyDISK3				;DISK3: READ 6 BYTE ID RECORD
		POP	BC
		LD	A, (dcb + DSKSTS)
		OR	A
		JR	Z, SalySEL4B
		DJNZ	SalySEL4A

SalySEL4B:	LD	A, 028h					;reset JR Z,xx
		LD	(DISK3 + 031h), A
			
		POP	IX
		POP	HL
		POP	DE
		POP	BC
		LD	A, (dcb + DSKSTS)			;check disk status
		OR	A
		JR	NZ, SalySEL4ex				;not zero, no HD
		RES	6, B					;
SalySEL4ex:             
		LD	A, B
		LD	D, 0
		JP	SEL5

;--------------------------------------------------
; hook for read directSector if aux1/2 = 0
;--------------------------------------------------
dskrd1:
		LD	A, 2
		LD	(direct), A				;clear direct

		LD	HL, (CFRAME + 2)			;load DAUX1/2, test if zero
		LD	A, L
		OR	H
		JR	Z, dskrd2				;if zero, use direct sector number
		CALL	SECTRAN					;else use original code, call SECTRAN
		JP	SalyDISKRD2				;and procees

dskrd2:
		LD	IX, DKIOCB
		LD	(IX + DSKOP), TSTRDY
;		CALL	dumpdcb
		PUSH	HL
		CALL	DISKV
		POP	HL

		CALL	sec2track				;compute sector, track, side from direct sector
		LD	(IX + DSKOP), GETSEC
;		CALL	dumpdcb
		PUSH	HL
		CALL	dskreadfn				;CALL DISK I/O HANDLER
		POP	HL

		LD	A, (DKIOCB+DSKSTS)
		CALL	SETSTAT					;call SETSTAT
		LD	D, 0					;no invert
		JP	SENDBUFF				;jump SENDBUFF

;--------------------------------------------------
;compute sector, track, side from direct sector
;--------------------------------------------------
sec2track:
		XOR	A					;clear carry and a
		LD	B, 0ffh					;also b
		LD	HL, (dsector)				;compute track and side numer
		LD	DE, 18					;18 secs per track
sec2track1:             
		INC	B					;b holds track-number
		sbc	HL, DE
		JR	NC, sec2track1				;subtract 18 as long carry clear
		LD	A, L
		ADD	19					;add 19 to get sector number + 1
		LD	(DKIOCB+DSKSEC), A
		SRL	B					;divide track by two, (we have two sides)
		LD	A, B
		LD	(DKIOCB+DSKTRK), A
		RRA						;shift-in side-number from previously lowest-bit
		AND	080h					;mask out bit 0-6
		LD	HL, DKIOCB+DSKDRV
		RES	7, (HL)
		OR	(HL)
		LD	(HL), A
			
;		CALL	serhex
;		CALL	serspace
;		LD	A, 'S'
;		CALL	seroutfn
;		LD	A, (DKIOCB+DSKSEC)
;		CALL	serhex
;		CALL	serspace
;		LD	A, 'T'
;		CALL	seroutfn
;		LD	A, (DKIOCB+DSKTRK)
;		CALL	serhex
;		CALL	sercr
			
		LD	HL, 512
		LD	(DKIOCB+DSKAUX), HL
		LD	HL, IOBUFF
		LD	(DKIOCB+DSKPTR), HL
		LD	IX, DKIOCB
		RET     

;--------------------------------------------------
; hook for setDirectSector if aux1/2 = 0
;--------------------------------------------------
dwrt:		PUSH	HL
		LD	(LOGSIZ),HL				;SAVE DATA BLOCK LENGTH

		LD	HL, (CFRAME + 2)			;load DAUX1/2
		LD	A, L
		OR	H
		JR	Z, dwrta				;if zero, do special stuff

		POP	HL					;otherwise continue
		JP	SalyDISKWRT2				;normal

dwrta:		CALL	SENDACK

		LD	HL, direct				;direct
;		LD	A, (HL)
;		CALL	serhex
		DEC	(HL)
		JR	Z, dwrtd				;first sector
		JP	M, dwrtb				;second sector

		LD	B, 64
		DJNZ	$					;wait some time

		LD	HL, (IOBUFF)				;save 2-byte sector number (0-xxxx)
		LD	(dsector), HL

dwrtc:		POP	HL
		LD	A, 'C'
		JP	SENDCHAR

dwrtd:		LD	HL, IOBUFF
		LD	DE, IOBUFF+LEN+2
		LD	BC, 0100h				;rec first half
		LDIR
		JR	dwrtc

dwrtb:		LD	(HL), 2					;direct = 2

		LD	HL, 512					;LOGSIZ 512 bytes in this case
		LD	(LOGSIZ), HL
			
		LD	HL, IOBUFF
		LD	DE, IOBUFF+0100h
		LD	BC, 0100h
		LDIR    
		LD	HL, IOBUFF+LEN+2
		LD	DE, IOBUFF
		LD	BC, 0100h
		LDIR

		CALL	sec2track

		LD	(IX + DSKOP), PUTSEC
		CALL	dskwrite

		JR	dwrtc
;--------------------------------------------------
; dskwrite: write through sector
;--------------------------------------------------
dskwrite:
;		LD	A, 'W';
;		CALL	seroutfn

;		JP	DISKV

		CALL	checktrack
		JR	NZ, dskwrite1

;		LD	HL, (LOGSIZ)
;		CALL	seraddr

		CALL	compbufadr
;		CALL	seraddr

		EX	DE, HL
		LD	H, (IX + DSKPTR+1)
		LD	L, (IX + DSKPTR)
		LD	BC, (LOGSIZ)

		LDIR

dskwrite1:
		JP	DISKV


;--------------------------------------------------
; dskreadfn: cache a track
;--------------------------------------------------
dskreadfn:
;		LD	A, 'R'
;		CALL	debug

		CALL	checktrack
		JP	Z, match
; 		ld	a, 'N'
;		CALL	seroutfn
		LD	(drive), DE				;save new drive and track
		PUSH	IX					;save IX

		PUSH	IX					;load HL with IX
		POP	HL
		LD	DE, dcb
		LD	BC, 9
		LDIR						;copy dcb
			
		LD	IX, dcb					;load IX with new dcb
			
		LD	A, (dcb + DSKAUX+1)			;get sector length high-byte
		CP	2
		JR	NZ, readtrack2				;no MS-DOS disk


		LD	HL, TRKBUFFER
		LD	BC, 18 * 256 + 1			;b=18, c = 1

readtrack3:
		LD	(dcb + DSKPTR), HL
		LD	(IX + DSKSEC),	C

;		CALL	dumpdcb

		PUSH	HL
		PUSH	BC
		CALL	DISKV
		POP	BC
		POP	HL
;		CALL	dumpsec 
		LD	A, (dcb + DSKSTS)			;error occured?
		OR	A
		JR	NZ, readtrack4				;yes
		INC	H
		INC	H
		INC	C
		DJNZ	readtrack3
		JR	readtrack5

readtrack2:
		LD	B, 0					;compute skew-list from media type
		LD	C, (IY + MEDIA)
		LD	HL, skewtab
		ADD	HL, BC
		LD	A, (HL)
		INC	HL
		LD	H, (HL)
		LD	L, A
		LD	B, (IY + NSECS+1)

readtrack1:
		LD	(secptr), HL

readtrack:
		LD	HL, (secptr)
		LD	A, (HL)
		LD	(dcb + DSKSEC), A
		INC	HL
		LD	(secptr), HL

		PUSH	BC
		CALL	compbufadr
		LD	(dcb + DSKPTR), HL
;		CALL	dumpdcb
		CALL	DISKV
		POP	BC

		LD	A, (dcb + DSKSTS)			;error occured?
		OR	A
		JR	Z, readtrack6				;no
readtrack4:             
		LD	HL, 0ffffh
		LD	(drive), HL
		POP	IX					;yes, store in original dcb
		JR	match2
readtrack6:             
		DJNZ	readtrack
readtrack5:
		POP	IX

match:
;		ld	a, 'M'
;		CALL	seroutfn
		
		CALL	compbufadr
		LD	D, (IX + DSKPTR+1)
		LD	E, (IX + DSKPTR)
		LD	BC, (LOGSIZ)
		LD	A, (dcb + DSKAUX+1)			;get sector length high-byte
		CP	2
		JR	NZ, match1
		LD	BC, 512
match1:
		LDIR

		XOR	A
match2:
		LD	(IX + DSKSTS), A

	IF	WD1772
		LD	A, FINCMD				;keeps motor spinning
		CALL	SalyCMDOUT
	ENDIF
		JP	ACTIVON


;--------------------------------------------------
; HL = TRKBUF + DSKSEC * (128/256/512)
;--------------------------------------------------
compbufadr:
		LD	HL, TRKBUFFER
		LD	B, (IX + DSKSEC)
		DEC	B
		LD	C, 0
		LD	A, (dcb + DSKAUX + 1)			;load seclen highbyte
		OR	A
		JR	Z, compbufadr2				;if zero, assume 128 bytes length
		CP	1
		JR	Z, compbufadr1				;if 1, assume 256 bytes
		SLA	B					;512 bytes
		JR	compbufadr1
compbufadr2:
		SRL	B					;128 bytes
		RR	C
compbufadr1:
		ADD	HL, BC
		RET

checktrack:
		LD	HL, (drive)				;load
		LD	D, (IX + DSKTRK)			;high
		LD	E, (IX + DSKDRV)			;low
		OR	A					;clear carry
		SBC	HL, DE
		RET
;
;
;--------------------------------------------------
; get Pokeydivisor command '?'
;--------------------------------------------------
;
;
getspeed:
;		LD	A, '?'
;		CALL	seroutfn

		CALL	DRVINDEX				;POINT IY TO DRIVE'S DATA AREA
		RET	C					;EXIT IF NOT A DRIVE IN OUR BOX

;		CALL	HASPARMS
;		RET	Z					;EXIT IF DISK PARAMS NOT KNOWN

		CALL	SENDACK					;SEND 'ACK' FOR COMMAND FRAME

		LD	HL, IOBUFF+LEN-1

	IF NOHIGHSPEEDSIO <> 1
		LD	A, SIOFAST
		LD	(HL), A
	ELSE
		LD	(HL), SIONORMAL
	ENDIF	; HIGHSPEEDSIO

		LD	DE, 'C'
		JP	SENDBUFF				;SEND 'C' AND PARAMS DATA FRAME

;
;
	IF SALLYRS = 1
;
;--------------------------------------------------
;	... PERCOM 'N' COMMAND PROCESSOR ...
;--------------------------------------------------
;
;
;
GETPARAMS:
		CALL	DRVINDEX	;POINT IY TO DRIVE'S DATA AREA
		RET	C		;EXIT IF NOT A DRIVE IN OUR BOX
	
;		CALL	HASPARMS
;		RET	Z		;EXIT IF DISK PARAMS NOT KNOWN
	
		CALL	SENDACK		;SEND 'ACK' FOR COMMAND FRAME

		call	diskanalyse
		
		call	dumppercom

;		SET	CONFIG,(IY+FLAGS)
GETPARAMS1	PUSH	IY
		POP	HL
		LD	DE,IOBUFF+LEN-12
		PUSH	DE
		LD	BC,12
		LDIR			;COPY PARAMS TO OUTPUT BUFFER
		POP	HL
		ld	d, 0
		ld	a, (siorc)
		ld	e, a
		JP	SENDBUFF	;SEND 'C' AND PARAMS DATA FRAME
		
;
;
;
;--------------------------------------------------
; Disk status
;--------------------------------------------------
;
;
;
diskstatus:	CALL	DRVINDEX		;POINT IY TO DRIVE'S DATA AREA
		RET	C			;EXIT IF NOT A DRIVE IN OUR BOX

		CALL	SENDACK			;SEND 'ACK' FOR COMMAND FRAME

		call	diskanalyse
		jr	C, diskstatus4
		
		call	waitstatus		;get idle status for motor on
		ld	b, a			;save status from FDC
			
		ld	a, not BADRW
		and	(IY + CMDSTS)		;keep BADRW
		
		bit	7, b			;motor on?
		jr	z, diskstatus1		;no
		set	ACTIVE, a

diskstatus1:	bit	DENSTY, (IY + MEDIA)	;double density?
		jr	z, diskstatus2		;no
		set	SEC256, a

diskstatus2:	bit	6, (IX + DSKSTS)	;last command wp?
		jr	z, diskstatus3		;no
		set	WRPROT, a

diskstatus3:	bit	SEC256, a
		jr	NZ, diskstatus5
		ld	b, a
		ld	a, (IY + NSECS + 1)
		cp	26
		ld	a, b
		jr	NZ, diskstatus5
		set	7, a
		
diskstatus5:	ld	hl, statbytes
		ld	(hl), a
;		call	serhex
		ld	a,(IY+HDWSTS)
		cpl
		inc	hl
		ld	(hl), a
		
		dec	hl
		ld	de, IOBUFF+LEN-4
		ld	bc, 4
		ldir				;COPY PARAMS TO OUTPUT BUFFER
		
diskstatus4:	ld	d, 00h			;true data
		ld	a, (siorc)		;get rc to br returned
;		call	seroutfn
		ld	e, a
		ld	hl, IOBUFF+LEN-4
		JP	SENDBUFF		;SEND 'C' or 'E' AND PARAMS DATA FRAME		

statbytes:	DEFB	0h, 0ffh, 224, 0

	ENDIF
;
;
;
;--------------------------------------------------
; Disk read
;--------------------------------------------------
;
;
;
diskreadfn:	call	DRVINDEX		;POINT IY TO DRIVE'S DATA AREA
		ret	C			;EXIT IF NOT A DRIVE IN OUR BOX
	
diskreadfn2:	call	SENDACK			;SEND 'ACK' FOR COMMAND FRAME
		
		call	isspinning
		jr	C, diskreadfn3
				
		call	diskanalyse
		jr	C, diskreadfn3
			
		call	checkmaxsec		;check if sio sector > max sector
		jr	C, diskreadfn3		;no carry, ok

		call	sec2trk			;compute head / track / sec and seek

		ld	a, (OUTCPY)		;make head info as bit 7
		rla
		rla
		and	10000000b
		or	(IX + DSKDRV)
		ld	b, a
		ld	c, (IX + DSKTRK)	;BC = DRIVE/TRACK
		
		ld	hl, (drive)
		sbc	hl, bc			;or above, carry clear!
		jr	z, trkmatch
		
		call	readtrk
		call	compdskbuf
		
trkmatch:	call	computesecbuf
		
;		call	sercr
;		call	seraddr
;		call	serspace
;		ex	de, hl
;		call	seraddr
;		call	serspace
;		push	bc
;		pop	hl
;		call	seraddr
;		call	serspace
		
		ld	a, RDCMD
		call	diskop			;call diskio routine

diskreadfn3:	call	adjustsiobuf
		ld	d, 0ffh			;invert data
		ld	a, (siorc)
		ld	e, a
		jp	SENDBUFF		;SEND 'C' AND PARAMS DATA FRAME	

;
;
;
readtrk:	ret
		call	readidam

		call	getskewtab

		ld	a, (idsector)
		ld	b, (IY + NSECS + 1)	;loop over #secs		
;		call	serhex
readtrk1:	cp	(hl)
		jr	Z, readtrk2		;initial secnr found
		inc	hl
		jr	readtrk1
		
readtrk2:	inc	hl
		ld	a, (hl)
		or	a
		jr	NZ, readtrk3
		call	getskewtab
		ld	a, (hl)

readtrk3:	ld	c, (IX + DSKSEC)
		ld	(IX + DSKSEC), a
		push	bc
		push	hl
		call	computesecbuf
		call	seraddr
		call	serspace
		pop	hl
		pop	bc
		ld	(IX + DSKSEC), c

		djnz	readtrk2
		
		ret


computesecbuf:
		ld	d, (IY + SECLEN)	;hi
		ld	e, (IY + SECLEN + 1)	;lo
		push	de
		ld	b, (IX + DSKSEC)	;sec to be read;
		ld	hl, 0
trkmatch1:	add	hl, de
		djnz	trkmatch1		;compute start of sector
		or	a
		sbc	hl, de
		ld	de, TRKBUFFER
		add	hl, de
		ld	de, IOBUFF+LEN-256
		pop	bc
		ret

getskewtab:
		push	iy
		pop	hl
		ld	de, PERSKEWTAB
		add	hl, de
		ret
;
;
;
;--------------------------------------------------
; Disk write
;--------------------------------------------------
;
;
;
diskwritefn:	call	DRVINDEX		;POINT IY TO DRIVE'S DATA AREA
		ret	C			;EXIT IF NOT A DRIVE IN OUR BOX
					
diskwritefn2:	call	SENDACK			;SEND 'ACK' FOR COMMAND FRAME

		CALL	RECVBUFF		;ATTEMPT TO READ DATA FRAME FROM ATARI
		RET	NZ

		LD	(DKIOCB + DSKAUX),HL	;SAVE DATA BLOCK LENGTH
		LD	DE,128
		OR	A
		SBC	HL,DE			;TEST FOR 128 BYTE FRAME
		JR	Z,diskwritefn1
		OR	A
		SBC	HL,DE			;TEST FOR 256 BYTE FRAME
		RET	NZ		
		
diskwritefn1:	call	SENDACK			;SEND 'ACK' IF BLOCKSIZE IS 128 OR 256
			
		call	isspinning
		jr	C, diskwritefn4
		
		call	diskanalyse
		jr	C, diskwritefn4
		
		call	checkmaxsec		;check if sio sector > max sector
		jr	C, diskwritefn4		;no carry, ok
		
		call	sec2trk			;compute head / track / sec and seek

		ld	hl, IOBUFF
		ld	(DKIOCB + DSKPTR), hl

		ld	b, (IX + DSKAUX)	;complement data frame, only up to 256 byte sectors
diskwritefn5:	ld	a, (hl)
		cpl
		ld	(hl), a
		inc	hl
		djnz	diskwritefn5

		ld	a, (IY + SECLEN)
		ld	(DKIOCB + DSKAUX + 1), a
		ld	a, (IY + SECLEN + 1)
		ld	(DKIOCB + DSKAUX), a

		ld	a, WRTCMD
		call	diskop			;call diskio routine
		ld	a, (IY + CMDSTS)
		call	serhex
		
diskwritefn4:	ld	a, (siorc)
;		call	seroutfn
		ld	e, a
		jp	SENDCHAR		;SEND 'C' AND PARAMS DATA FRAME	


;
;
;	... DISK FORMAT COMMAND PROCESSOR ...
;
diskformat:
		CALL	DRVINDEX		;POINT IY TO DRIVE'S DATA AREA
		RET	C			;EXIT IF NOT A DRIVE IN OUR BOX
						
		LD	HL,(PCOUNT)             
		LD	A,H                     
		OR	L                       
		RET	NZ			;REFUSE TO FORMAT IF SPOOLER ACTIVE
						
		ld	a, (IY + NTRKS) 	;REFUSE TO FORMAT IF PARAMS NOT SET
		or	a                       
		ret	Z                       
						
		call	SENDACK                 
		call	STOPTMR			;THEN KILL CTC3 TO STOP DISK TIMER
						
		ld	a, 'C'
		ld	(siorc), a

		call	computeflags
		
		ld	(OUTCPY), a
		out	(LATCH), a
		call	serhex

		push	af
		call	restoretrack
		pop	af
		
		push	hl
	
		ld	(SEQPTR), hl			;STORE POINTER FOR BAD SECTOR LIST
		ld	hl , 1
		ld	(SEQNUM), HL			;RESET BAD SECTOR COUNTER
		ld	HL, (FMTPTR)			;pointer to formats
		ld	DE, FMTSTUFF
		ld	BC, FMTLEN
		rlca
		rlca
		and	00000011B
		jr	Z, diskformat5
diskformat2:	add	HL,BC
		dec	A
		jr	NZ, diskformat2			;INDEX TO PROPER PARAMS FOR DISK TYPE
		
diskformat5:	ld	a, (siocmd)			;check for medium density
		call	serhexspace
		cp	'"'
		jr	NZ, diskformat1
		ld	hl, (FMTPTR)
		add	hl, bc
		add	hl, bc
		add	hl, bc
		add	hl, bc
		ld	a, (OUTCPY)
		and	00111111b
		or	01000000b
		ld	(OUTCPY), a
		ld	(IY + FLAGS), a
		out	(LATCH), a
;		ld	(IY + NSECS + 1), 26

diskformat1:	call	seraddr
		ldir					;THEN COPY PARAMS TO 'FMTSTUFF'
		ld	A,(DKIOCB+DSKSTS)
		and	11000000B
		jr	NZ, diskformat6			;ERROR IF NOT READY OR WRITE PROTECTED
	
		ld	a,(iy+nsides)			;set for SS/DS init
		ld	(sides),a
		ld	a,(iy+ntrks)			;set for number of tracks
		ld	(tracks),a
		push	IY
		push	IX
		call	FORMAT				;CALL FORMAT SUBROUTINE
		pop	IX
		pop	IY


diskformat6:	res	7, a
		push	af
		ld	a, ':'
		call	seroutfn
		pop	af
		call	serhex
		CALL	SETSTAT				;UPDATE STATUS AS SPECIFIED BY ACC
		
		ld	(IY + FLAGS), 0
;		call	serinfn
		call	diskanalyse			;compute maxsec
;		call	restoretrack
		call	dumppercom
		
		POP	HL
		LD	D,0
		ld	a, (siorc)
		ld	e, a
		jp	SENDBUFF			;SEND BAD SECTOR DATA FRAME
;		JP	ACTIVON		;THEN RESTART THE DISK TIMER
	
;--------------------------------------------------
; computeflags
;--------------------------------------------------
computeflags:	ld	(IY + PERSTEPRATE), STEPRATE0
		call	getdrivelatch
		ld	b, a
		
		ld	hl, IOBUFF+LEN-256	;256 byte bad sector list
		bit	DENSTY, (IY + MEDIA)    
		jr	nz, computeflags1         
		ld	HL, IOBUFF+LEN-128	;128 byte bad sector list
		set	6, b			;and no HD
		ld	(IY + PERSTEPRATE), STEPRATE3
		ld	a, (IY + NSECS + 1)
		cp	26
		jr	Z, computeflags4
		set	7, b			;set single density (FM)
		jr	computeflags4
;
; HD/DD selection
; number sector >= 26 and sector-size > 128 then hd
;
computeflags1:	bit	7, (IY + SECLEN + 1)		;bit 7 - low byte (128) = 1?
		jr	NZ, computeflags3		;probably medium density
		ld	a, (IY + NSECS + 1)
		cp	26
		jr	NC, computeflags4		;>= 26 HD
computeflags3:	set	6, b				;< 26 sectores, normal DD
computeflags4:	ld	a, b
		ld	(IY + FLAGS), a
		ret
;--------------------------------------------------
; compdskbufbuf
; siorc default to 'C' - complete
; copy percom sector length to IX + DSKAUX
; computer start of serial buffer (IOBUF+LEN - seclen)
;--------------------------------------------------
compdskbuf:
		ld	a, 'C'
		ld	(siorc), a

		ld	h, (IY + SECLEN)	;compute start of disk-data
		ld	l, (IY + SECLEN + 1)	;in transfer buffer
		ld	(DKIOCB + DSKAUX), hl
		ex	de, hl
		or	a
		ld	hl, IOBUFF+LEN
		sbc	hl, de
		ld	(DKIOCB + DSKPTR), hl
		ld	(siobuffer), hl
		ret

;--------------------------------------------------
; adjustsiobufbuf
; if sector < 4, copy data to IOBUF+LEN - 128
; return start of SIo buffer in HL
;--------------------------------------------------
adjustsiobuf:	
		ld	a, (IY + FLAGS)
		or	a
		jr	NZ, adjustsiobuf1
		ld	hl, IOBUFF+256
		xor	a
		jr 	adjustsiobuf2

adjustsiobuf1:	ld	hl, (DKIOCB + DSKPTR)
		ld	a, (IX + DSKAUX)		;sectorlen < 256
		or	a
		ret	NZ				;yes, do nothing
		
adjustsiobuf2:	ld	a, (siosector + 1)		;hi-byte <> 0
		or	a
		ret	NZ				;yes, no nothing
		
		ld	a, (siosector)		
		cp	4
		ret	NC				;>= 4

		push	hl
		ld	bc, 128
		add	hl, bc
		ex	de, hl				;de = hl+128
		pop	hl				;hl = diskbuffer
		ldir

		ret
		
;--------------------------------------------------
; diskanalyse - compute PERCOM values
;--------------------------------------------------
diskanalyse:	ld	a, 'C'
		ld	(siorc), a
		
		ld	a, (IY + FLAGS)			;check if percom empty
		ld	(OUTCPY), a			;set LATCH und OUTCPY
		out	(LATCH), a
		or	a
		ret	NZ				;no continue without disk analyse

		
		ld	(IY + MEDIA), 4			;set DD (MFM)
		ld	(IY + PERCONFIG), 3		;set SIZE and DDHD
		ld	(IY + NSIDES), 0
		ld	(IY + PERSTEPRATE), STEPRATE0	;select 6ms/3ms
		
		call	getdrivelatch
		ld	(IY + FLAGS), a	
		out	(LATCH), a
		ld	(OUTCPY), a

		call	restoretrack

		call	getperiod
		jr	NC, diskanalyse3		;if no period, error

diskanalyse2:	ld	a, '-'
		call	seroutfn
		ld	(IY + FLAGS), 0
		jp	setsioerror
		
diskanalyse3:	ld	a, (IY + FLAGS)	
		out	(LATCH), a	
		call 	tryidam	
		jr	z, diskanalyse1	

		bit 	6, (IY + FLAGS)			;DD already set?
		jr	nz, diskanalyse4		;yes	
		set	6, (IY + FLAGS)			;switch back to DD
		res	DDHD, (IY + PERCONFIG)		;reset DDHD
		ld	(IY + PERSTEPRATE), STEPRATE3	;set to 3ms in DD mode
		jr	diskanalyse3	
			
diskanalyse4:	bit 	7, (IY + FLAGS)			;FM already set?
		jp	nz, diskanalyse2		;bail out with C set
		set	7, (IY + FLAGS)			;set FM
		res	DENSTY, (IY + MEDIA)		;reset DENSTY (FM/MFM)
		jr	diskanalyse3	

;
; arrive here if IDAM has been found
; check for track 41 to be readable
;
diskanalyse1:	ld	a, 40				;check for track 41
		ld	(IY + NTRKS), a
		ld	(IX + DSKTRK), a
		call	seektrack
		call 	tryidam
		jr	nz, diskanalyse8
;
; track 41 was readable, check if ID holds also track 41
; if not is was a 40 TRK drive and the head hit the bottom
;
		ld	a, (idtrack)
		cp	(IY + NTRKS)
		jr	nz, diskanalyse8
		
;
; now check for track 77
;
		ld	a, 77
		ld	(IY + NTRKS), a			;assume at least 77 tracks
		ld	(IX + DSKTRK), a
		call	seektrack
		call 	tryidam
		jr	nz, diskanalyse8

		ld	a, (idtrack)
		cp	(IY + NTRKS)
		jr	nz, diskanalyse8

		ld	a, (idseclen)			;check seclen
		and	a, 3
		cp	1				;has to be a 256 byte sector
		jr	nz, diskanalyse8
		
		ld	(IY + NTRKS), 80
		
diskanalyse8:	call	restoretrack			;restore and check other side
	
		set	5, (IY + FLAGS)			;set side 1
		ld	a, (IY + FLAGS)
		out	(LATCH), a
		call 	tryidam
		jr	nz, diskanalyse6
		
		inc	(IY + NSIDES)

diskanalyse6:	res	5, (IY + FLAGS)			;set side 0
		ld	a, (IY + FLAGS)
		out	(LATCH), a
		ld	(OUTCPY), a			;set LATCH und OUTCPY

		call	readskew
;		call 	tryidam				;read fresh IDAM (could be CRC error from above)	
		
		ld	a, (idseclen)			;compute sector length
		and	3				;from IDAM field
		inc	a
		ld	hl, 64
compseclen:	sla	l
		rl	h
		dec	a
		jr	NZ, compseclen	
		ld	(IY + SECLEN), h
		ld	(IY + SECLEN + 1), l
		
;		call	seraddr		

		ld	(IY + NSECS), 0
		ld	(IY + NSECS + 1), 18
		bit	6, (IY + FLAGS)			;HD mode, set to 26
		jr	Z, diskanalyse10
		bit	7, (IY + FLAGS)			;MFM mode 
		jr	NZ, diskanalyse5
		ld	a, (IY + SECLEN)		;and seclen < 256
		or	a
		jr	NZ, diskanalyse5 		;then set also to 26
		ld	(IY + MEDIA), a

diskanalyse10:	ld	(IY + NSECS + 1), 26
		
diskanalyse5:	ld	hl, 0				;compute PERcom MAXSEC
		ld	b, (IY + NTRKS)
		ld	d, (IY + NSECS)			;compute max sector
		ld 	e, (IY + NSECS + 1)		;NSECS by NTRKS
diskanalyse7:	add	hl, de
		djnz	diskanalyse7			;multiply
		bit	0, (IY + NSIDES)
		jr	z, diskanalyse9
		add	hl, hl				;double
diskanalyse9:	ld	(IY + PERMAXSEC), l		;save as low/hi pair
		ld	(IY + PERMAXSEC + 1), h

		ld	a, 'C'
		ld	(siorc), a
		ld	a, (IY + FLAGS)			;return LATCH bytes
		or	a				;return carry clear
		ret

;--------------------------------------------------
; readskew
;--------------------------------------------------
readskew:
		push	iy
		pop	hl
		ld	bc, PERSKEWTAB
		add	hl, bc
		ld	b, 36
		ex	de, hl
		push	de
		
readskew1:	push	bc
		push	de
		call	readidam
		pop	de
		pop	bc
		
		pop	hl
		push	hl
		ld	a, (idsector)
readskew6:	push	hl
		or	a
		sbc 	hl, de
		pop	hl
		jr	Z, readskew4				;store value if c = 0		
		cp	(hl)					;did we have this sector already?
		jr	Z, readskew5				;get out of loop
		inc	hl
		jr	readskew6
		
readskew4:	ld	(de), a
		inc	de
		djnz	readskew1

readskew5:	xor	a
		ld	(de), a
		pop	hl
		
;		call	sercr
;		ld	b, 36
;readskew2:	ld	a, (hl)
;		or	a
;		ret	Z
;		call	serhexspace
;		inc	hl
;		djnz	readskew2
readskew3:	ret
		
;--------------------------------------------------
; checkmaxsec
; compare zero
; compare against max sector
;--------------------------------------------------
checkmaxsec:
		ld	hl, (siosector)
		dec	hl
		
		ld	d, (IY + PERMAXSEC + 1)		;siosec - maxsec
		ld	e, (IY + PERMAXSEC)
		or	a
		sbc	hl, de
		ccf
		ret	NC

		jp	setsioerror

	IF SALLYRS = 1
;--------------------------------------------------
; DRVINDEX 64 Bytes per drive
;--------------------------------------------------

DRVINDEX:
	ld	hl, (CFRAME + 2)
	ld	(siosector), hl
	ld	hl, (CFRAME)
	ld	(siounit), hl
	
	ld	a, l	
;	ld	a,(CFRAME)	;GET DRIVE# FROM COMAND FRAME
	sub	'1'
	cp	4
	ccf
	ret	C		;EXIT IF NOT DRIVE 1,2,3 OR 4

	ld	h,0
	ld	l,a
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl		;MULTIPLY DRIVE INDEX BY 64
	
	ld	bc, drivedata
	add	hl, bc		;INDEX TO DRIVE'S PARAMETERS
	push	hl
	pop	iy		;GET POINTER INTO IY FOR RETURN
	bit	PRESENT, (IY + DSKBITS)
	scf
	ret	Z		;EXIT IT DRIVE NOT PRESENT

	ld	IX, DKIOCB
	ld	(DKIOCB+DSKDRV), a
	xor	a
	ret
;
	ENDIF
;
				
;--------------------------------------------------
; getdrivelatch
;--------------------------------------------------
getdrivelatch:
		ld	a, (DKIOCB+DSKDRV)
		inc	a
		ld	b, a
		xor	a
		scf
getdrivelatch1:	rla
		djnz	getdrivelatch1
		ret

;--------------------------------------------------
; isspinning
;--------------------------------------------------
isspinning:	in	a, (STSREG)			;Motor on?
		and	10000000b			;mask bit 7 and clear carry
		ret	NZ				;yes
		
		call	getdrivelatch
		out	(LATCH), a			;fall through to getperiod
		
;--------------------------------------------------
; getperiod
;--------------------------------------------------
getperiod:	ld	de, 3000

getperiod1:	dec	de				;get an Index within x iterations
		ld	a, d
		or	e
		jr	z, getperiod4
		call	getfdcstatus
		jr	C, getperiod4			;no status at all
		bit	1, a
		jr	z, getperiod1
			
		ld	h, 0
		
getperiod2:	call	getfdcstatus
		bit	1, a
		jr	nz, getperiod2

getperiod3:	inc	hl
		call	getfdcstatus		
		bit	1, a
		jr	z, getperiod3

;		call	seraddr
		or	a
		ret
		
getperiod4:	
		call	SalyResetFDC

		xor	a
		out	(LATCH), a
		
setsioerror:	ld	a, 'E'
		ld	(siorc), a
		scf
		ret
		
;--------------------------------------------------
; seektrack
;--------------------------------------------------
seektrack:
		ld	a, (IY + PERTRACK)		;populate track reg
		out	(TRKREG), a			;from number stored
		ld	a, (IX + DSKTRK)		;seek to track
		out	(DATREG), a			;into DATREG
		ld	a, (IY + PERSTEPRATE)
		add	a, SKCMD	
seektrack1:	out	(CMDREG), a			;issue step command
		call	waitstatus
		ld	a, (IX + DSKTRK)		;update registers
;		out	(TRKREG), a
		ld	(IY + PERTRACK), a
		ret
		
;--------------------------------------------------
; restoretrack
;--------------------------------------------------
restoretrack:	ld	a, (IY + PERSTEPRATE)
		add	a, RSTCMD
		out	(CMDREG), a
		call	waitstatus
		
		xor	a
		ld	(IY + PERTRACK), a
		ld	(IX + DSKTRK), a
		out	(TRKREG), a
		ret
;--------------------------------------------------
; getfdcstatus
;--------------------------------------------------
getfdcstatus:	in	a, (TRKREG)			
		out	(DATREG), a
		ld	a, SKCMD
		out	(CMDREG), a			
		
;--------------------------------------------------
; waitstatus
;--------------------------------------------------
waitstatus:	ld	bc, 30000

waitstatus1:	LD	A,14	
		DEC	A
		JR	NZ,$-1	;DELAY 56 MICROSECONDS

		in	a, (STSREG)
		or	a
		bit	0, a
		ret	z
		
		dec	bc
		ld	a, b
		or	a, c
		jr	nz, waitstatus1
		
		scf
		ret
		
;--------------------------------------------------
; read an IDAM
;--------------------------------------------------
readidam:	ld	hl, 6
		ld	(DKIOCB + DSKAUX), hl
		ld	hl, idambuf
		ld	(DKIOCB + DSKPTR), hl
		ld	a, RIDCMD
;		call	diskop					;fall through
;		ret
		

;--------------------------------------------------
; general disk operation
;--------------------------------------------------
diskop:		ld	(CMDBYT), a
		ld	hl, 0a2edh	;12 LOAD HL WITH 'INI' OPCODE
		bit	5, a		;check if write command
		jr	z, diskop1
		inc	h		;change to outi
diskop1		LD	(NMIVEC), hl
		LD	HL,NMIVEC+2	;12
		LD	(HL),0C9H	;10 STORE 'RET' OPCODE AFTER INI/OUTI

;		call	resetcmd
		
;		call	dumpiocb
		
		ld	c, DATREG
		ld	a, (IX + DSKAUX)
		ld	b, a
		ld	hl, (DKIOCB + DSKPTR)
		
		ld	a, (IX + DSKSEC)
		out	(SECREG), a

		ld	a, (CMDBYT)				
		out	(CMDREG), a
		
		ld	a, (IX + DSKAUX+1)
		srl	a											;8
		jr	Z,read256	;JUMP IF BLOCKSIZE <= 256 BYTES						;12
		srl	a
		jr	Z,read512	;JUMP IF BLOCKSIZE <= 512 BYTES

;
; 16 uS time at 500khZ
;
read1024:	halt
		jr	NZ, $-1
		halt
		jr	NZ, $-1
read512:	halt
		jr	NZ, $-1
read256:	halt
		jr	NZ, $-1
		call	waitstatus	
		in	a, (STSREG)		
		and	01111111b
		call	SETSTAT
		ld	a, e
		ld	(siorc), a
		ret
		
;--------------------------------------------------
; sec2trk
; compute IX + DSKSEC and IX + DSKTRK from siosector
;--------------------------------------------------
sec2trk:	ld	hl, (siosector)		;sector from SIO 
		dec	hl			;minus 1	
		xor	a			;track to zero
		ld	d, a
		ld	e, (IY + NSECS + 1)	;load DE with assumed sec per track
		
sec2trk2:	or	a			;compute track number siosector / NSECS
		sbc	hl, de
		jr	c, sec2trk1
		inc	a
		jr	sec2trk2
		
sec2trk1:	ld	(IX + DSKTRK), a	;track to be read
		cp	(IY + NTRKS)		;check if > NTRKS
		jr	C, sec2trk3
		sub	(IY + NTRKS)
		ld	(IX + DSKTRK), a
		ld	a, (OUTCPY)
		set	5, a			;set head 1
		ld	(OUTCPY), a
		out	(LATCH), a
	
sec2trk3:	ld	a, l
		add	a, (IY + NSECS + 1)	;add NSECS we have subtracted too much 
		inc 	a			;offset by 1
		ld	(IX + DSKSEC),a		;store in IOCB
		
		jp	seektrack

;--------------------------------------------------
; tryidam
;--------------------------------------------------
tryidam:	call	readidam		;try to get an id in MFM / HD

		in	a, (STSREG)
		and	00011100b
		
;		push	af
;		push	af
;		ld	a, 'i'
;		call	seroutfn
;		pop	af
;		call	serhex
;		pop	af
		
		ret
	
;--------------------------------------------------
; cmdwaitfn
;--------------------------------------------------
cmdwaitfn:	;in	a, (STSREG)
		;rla
		;jr	c, cmdwaitfn1
		;xor	a
		;out	(LATCH), a
		
cmdwaitfn1:	LD	A, (CMDFLG)
		OR	A					;SEE IF COMMAND FRAME HAS ARRIVED
		RET	Z					;EXIT IF NOTHING HAS HAPPENED

		call	sercmd
		
		LD	A, (CMDFLG)
		CP	1

		DI						;ELSE RESET INTERRUPT AND START AGAIN
		LD	A, CTC_D1_SW_RST + CTC_D0_CONTROL	;SOFTWARE RESET CTC0
		OUT	(CTC0), A				;PERFORM THE RESET
		EI

;		JP	Z, CMDL4				;good cmd-frame
								;fall through
		JR	NZ, togglebaud
	IF SALLYRS = 2
		CALL	sercmd					;5-byte command frame
	ENDIF
		JP	CMDL4
		
;--------------------------------------------------
; togglebaud
;--------------------------------------------------
togglebaud:
		LD	A, (pokeydiv)
		CP	SIONORMAL
		LD	A, SIOFAST
		JR	Z, togglebaud1
		LD	A, SIONORMAL
togglebaud1:
		LD	(pokeydiv), A
;		CALL	serhex
		JP	CMDL5

;--------------------------------------------------
; xmitbuffn
;--------------------------------------------------
xmitbuffn:
		DI
		LD	A, (pokeydiv)				;is fast?
		CP	SIONORMAL
		JR	NZ, xmitfast				;yes, jump
		LD	BC, STARBIT
		JP	SalyXMITBUF


xmitfast:
		LD	A, CTC_D6_MODE_TIM + CTC_D2_TCNEXT + CTC_D1_SW_RST + CTC_D0_CONTROL
		OUT	(CTC1), A				;SOFWARE RESET CTC1
		LD	A, 1					;TIME CONSTANT OF 1 - 4uS pulses (1/4Mhz)*16
		OUT	(CTC1), A

xmitfast1:
		LD	A, (HL)					;7
		INC	HL					;6
		XOR	D					;4
		LD	C, A					;4
		ADD	A, E					;4
		ADC	0					;7
		LD	E, A					;4
		CALL	fastsend				;17 send byte in c (53 T-States)
		LD	A, H					;4
		CP	HIGH (IOBUFF+LEN)			;7
		JR	C, xmitfast1				;12/7 loop if buffer end not reached

		LD	A, CTC_D1_SW_RST + CTC_D0_CONTROL
		OUT	(CTC1), A				;SOFWARE RESET CTC1
		EI
		RET

fastsend:
		XOR	A					;4
		OUT	(ATROUT), A				;11

		PUSH	IX					;15
		POP	IX					;14
		LD	A, C					;4
		LD	B, 8					;7
		INC	BC					;6
		NOP						;4

fastsend1:
		NOP						;4
		CP	1					;7
		OUT	(ATROUT), A				;11
		RRCA						;4
		PUSH	IX					;15
		POP	IX					;14
		DJNZ	fastsend1				;13 / 8

		LD	A, r					;9
		LD	A, 1					;7
		OUT	(ATROUT), A				;11
				
		RET						;10
		

;--------------------------------------------------
; rxblck
;--------------------------------------------------
rxblck:
		LD	A, (pokeydiv)				;is fast?
		CP	SIONORMAL
		JP	Z, rxblck1

		CALL	fastrecv				;yes, fast speed
		LD	A, CTC_D1_SW_RST + CTC_D0_CONTROL
		OUT	(CTC3), A				;SOFWARE RESET CTC3
		LD	C, D					;checksum in c
		RET

rxblck1:
		LD	BC, 0					;no, normal speed
		JP	SalyRXBLOCK


;--------------------------------------------------
; set 4ms watchdog
;--------------------------------------------------
irq4ms:
		POP	AF					;pop irq-addr
		OR	A					;clear carry
irq4ms1:
		EI
		RETI

;--------------------------------------------------
; SIO receive 57600 baud
;--------------------------------------------------
fastrecv:
		DI
		LD	BC, irq4ms
		LD	(CTCVEC+6),bc				;SET VECTOR TO irq4ms ROUTINE
		LD	BC, CTC3				;CLEAR B, LOAD C WITH ADDRESS OF CTC3
		LD	DE, CTC_D7_INT_EN + CTC_D6_MODE_TIM + CTC_D5_PRESC256 + CTC_D2_TCNEXT + CTC_D1_SW_RST + CTC_D0_CONTROL
		OUT	(C), E					;12 PUT CTC3 IN TIMER MODE, PRESCALE 256
		OUT	(C), C					;TIME CONSTANT OF 131 (CTC3 ADDRESS WHICH IS 083h)? 8.38ms? MAYBE MEANT , B
		EI

fastrecv1:              
		IN	A, (ATARI)				;11
		RLA						;4
		JP	C, fastrecv1				;10	NEW BYTE IS COMING IF START BIT LOW
								;14-25 / 7
		LD	A, D					;4
		ADD	A, B					;4
		ADC	A, 0					;7 ACCUMULATE CHECKSUM ATARI STYLE
		LD	D, A					;4
				
		LD	B, 07fh					;7
		jr	$+2					;10 = 50
;
; SERIAL->PARALLEL CONVERSION
; Pokey DIV 8 = 59114 / 59659 average 59400 baud equals about 68 T-states
;
fastrecv2:
		push	af					;11
		pop	af					;10
		in	a, (c)					;12
		
		IN	A, (ATARI)				;11 CYCLES
		RLA						; 4 CYCLES
		RR	B					; 8 CYCLES
		JR	C, fastrecv2				;12 = 69 / 65 cycles

		LD	(HL), B					;7 THEN STORE IN MEMORY BUFFER @HL
		INC	HL					;6
		LD	A, H					;4
		CP	HIGH (IOBUFF+LEN)			;7
		CCF						;4
		RET	C					;5 RETURN WITH CARRY SET IF BUFFER FILLED

		OUT	(C), E					;12 PUT CTC3 IN TIMER MODE, PRESCALE 256
		OUT	(C), C					;12 COUNT MOD 256 - ACTUALLY C = 131 (CTC3 ADDRESS WHICH IS 083h)? 8.38ms? MAYBE MEANT , B

		JP	fastrecv1				;10 = 82 

	if SALLYDEBUG = 1 
;--------------------------------------------------
; debug and dump rouines
;--------------------------------------------------


;--------------------------------------------------
; dump sector inverted
;--------------------------------------------------
serdumpcpl:
		PUSH	HL
		PUSH	AF
		PUSH	BC
		PUSH	DE
		LD	D, 255
		JP	serdump1


;--------------------------------------------------
; dump DKIOCB
;--------------------------------------------------
diskiodebug:	LD	a, (CMDBYT)
		CP	080h
		JR	NZ, diskiodebug1
		
		call	serhex
		LD	A,(IX+DSKTRK)	
		CALL	serhex
		LD	A,(IX+DSKSEC)	
		CALL	serhex

dbgRWBUSY:	IN	A,(STSREG)
		BIT	0,A
		JR	NZ,dbgRWBUSY				;LOOP TILL 1797 BUSY BIT GOES AWAY
		CALL	serhex

		CALL	sercr
	
diskiodebug1:	LD	A,(IX+DSKSEC)
		JP	DISK4+3
		
;--------------------------------------------------
; debug code for VR177x
; test 1 write/read TRKREG or SECREG 
;--------------------------------------------------
		DI
		
		CALL	sercr	
		
		in	a, (STSREG)
		CALL	serhex
		CALL	sercr

		call	serinfn
		
		LD	b, 0 
dloop:		LD	a, b
		CALL	serhex
		CALL	serspace
			
		out	(SECREG),a
		LD	c, 4				;4*8 = 32uS
dloop1:		DEC	c				;4
		JR	nz, dloop1			;12 = 16 T-states = 4uS
		
		in	a,(SECREG)
		
		CP	b
		JR	NZ, error
		DJNZ	dloop
ok:		JR	ok
		
error:		ld	a, 'E'
		CALL	seroutfn
error1:		JR	error1

;--------------------------------------------------
; dump 512 bytes at HL
;--------------------------------------------------
dumpsecinv	push	de
		ld	d, 255
		jr	dumpsec1
dumpsec:
		push	de
		ld	d, 0
		
dumpsec1:	push	bc
		push	hl
		call	sercr
		ld	c, 16
		
dumpline:	call	seraddr
		ld	a, ':'
		call	seroutfn
		
		ld	b, 16
dumpline1:	ld	a, (hl)
		xor	a, d
		call	serhexspace
		ld	a, b
		cp	9
		jr	NZ, dumpline5
		call	serspace
dumpline5:	inc	hl
		djnz	dumpline1

		ld	a, d
		ld	de, -16				;subtract 16 from hl
		add	hl, de
		ld	d, a
		ld	b, 16
		ld	a, '|'
		call	seroutfn
		
dumpline2:	ld	a, (hl)
		xor	a, d
		cp	32
		jr	C, dumpline3			;< 32
		cp	127				;< 127
		jr	C, dumpline4
dumpline3:	ld	a, '.'		
dumpline4:	call	seroutfn
		inc	hl
		djnz	dumpline2
		
		ld	a, '|'
		call	seroutfn
		call	sercr			
		
		dec	c
		jr	NZ, dumpline
		
		pop	hl
		pop	bc
		pop	de
		ret
		
;--------------------------------------------------
; Dump Percom Block in IY
;--------------------------------------------------
dumppercom:	push	af
		push	bc
		push	de
		push	hl
		
		push	iy
		pop	hl
		
		call	sercr
		
		ld	a, 'T'
		call	seroutfn
		ld	a, (hl)
		call	serhexspace
		
		inc	hl
		ld	a, 's'
		call	seroutfn
		ld	a, (hl)
		call	serhexspace

		inc	hl
		ld	a, 'S'
		call	seroutfn
		ld	a, (hl)
		call	serhex
		inc	hl
		ld	a, (hl)
		call	serhexspace

		inc	hl
		ld	a, 'H'
		call	seroutfn
		ld	a, (hl)
		call	serhexspace

		inc	hl
		ld	a, 'D'
		call	seroutfn
		ld	a, (hl)
		call	serhexspace

		inc	hl
		ld	a, 'L'
		call	seroutfn
		ld	a, (hl)
		call	serhex
		inc	hl
		ld	a, (hl)
		call	serhexspace
		
		inc	hl
		ld	a, '-'
		call	seroutfn
		ld	a, (hl)
		call	serhexspace

		ld	b, 3
dumppercom3:	inc	hl
		ld	a, (hl)
		call	serhexspace
		djnz	dumppercom3
		call	sercr

		push	iy
		pop	hl
		ld	bc, PERMAXSEC
		add	hl, bc
		ld	a, (hl)
		inc	hl
		push	hl
		ld	h, (hl)
		inc	hl
		ld	l, a
		ld	a, 'M'
		call	seroutfn
		call	seraddr
				
		call	sercr
		
		pop	hl
		inc	hl
		inc	hl
		ld	b, 36
		
dumppercom2:	ld	a, (hl)
		or	a
		jr	Z, dumppercom1
		call 	serhexspace
		inc	hl
		djnz	dumppercom2
		
dumppercom1:	call	sercr
		pop	hl
		pop	de
		pop	bc
		pop	af
		ret
		
;--------------------------------------------------
; Debug routine
;--------------------------------------------------
debugtrk:	CALL	seroutfn
		LD	A, (IX + DSKDRV)
		CALL	serhex
		LD	A, 't'
		CALL	seroutfn
		LD	A, (IX + DSKTRK)
		CALL	serhex
		LD	A, 's'
		CALL	seroutfn
		LD	A, (IX + DSKSEC)
		CALL	serhex
		LD	A, (IX + DSKPTR+1)
		CALL	serhex
		LD	A, (IX + DSKPTR)
		CALL	serhex
		LD	A, (IX + DSKAUX+1)
		CALL	serhex
		LD	A, (IX + DSKAUX)
		CALL	serhex

		CALL	serspace
		LD	A, (CFRAME+3)
		CALL	serhex
		LD	A, (CFRAME+2)
		CALL	serhex
		CALL	serspace
		LD	A, (IY+NSECS+1)
		CALL	serhex
		LD	A, (IY+NTRKS)
		CALL	serhex

		CALL	sercr
		RET
;--------------------------------------------------
; dump DKIOCB
;--------------------------------------------------
dumpiocb:
		PUSH	AF
		PUSH	BC
		PUSH	HL

		call	sercr
		ld	a, '%'
		call	seroutfn
		ld	a, (CMDBYT)
		call	serhexspace
		ld	a, '@'
		call	seroutfn
		ld	hl, (DKIOCB + DSKPTR)
		call	seraddr
		ld	a, '#'
		call	seroutfn
		ld	hl, (DKIOCB + DSKAUX)
		call	seraddr
		ld	a, 'H'
		call	seroutfn
		ld	a, (OUTCPY)
		rlca
		rlca
		rlca
		and	1
		call	serhexspace
		ld	a, 'T'
		call	seroutfn
		ld	a, (IX + DSKTRK)
		call 	serhexspace
		ld	a, 'S'
		call	seroutfn
		ld	a, (IX + DSKSEC)
		call 	serhexspace
		call	sercr

		POP	HL
		POP	BC
		POP	AF
		RET

;--------------------------------------------------
; RS232 sercmd
;--------------------------------------------------
sercmd:
		PUSH	HL
		LD	HL, CFRAME
		CALL	sercr
		call	serouthl
		call	serouthl		
		JR	serdump2
		
serouthl:	ld	a, (hl)
		inc	hl
		call	seroutfn
		jp	serspace
;--------------------------------------------------
; RS232 dump
;--------------------------------------------------
serdump:
		PUSH	HL
serdump2:
		PUSH	AF
		PUSH	BC
		PUSH	DE

		LD	D, 0
serdump1:
		LD	A, (HL)
		XOR	D
		CALL	serhex
		CALL	serspace
		INC	HL
		LD	A, H
		CP	A, 0c3h
		JR	C, serdump1

		POP	DE
		POP	BC
		POP	AF
		POP	HL
		RET

;--------------------------------------------------
; RS232 <space>
;--------------------------------------------------
serspace:
		PUSH	AF
		LD	A, ' '
		CALL	seroutfn
		POP	AF
		RET

;--------------------------------------------------
; RS232 <CR>
;--------------------------------------------------
sercr:
		PUSH	AF
		LD	A, CR
		CALL	seroutfn
		POP	AF
		RET

;--------------------------------------------------
; RS232 output HL in hex
;--------------------------------------------------
seraddr:	push	af
		ld	a, h
		call	serhex
		ld	a, l
		call	serhex
		call	serspace
		pop	af
		ret
		
;--------------------------------------------------
; RS232 output A in hex and trailing space
;--------------------------------------------------
serhexspace:	call	serhex
		jr	serspace
		
;--------------------------------------------------
; RS232 output A in hex
;--------------------------------------------------
serhex:
		PUSH	AF
		PUSH	AF
		RRCA
		RRCA
		RRCA
		RRCA
		CALL	sernib
		POP	AF
		CALL	sernib
		POP	AF
		RET

sernib:
		AND	0fh
		ADD	'0'
		CP	'9' + 1
		JR	C, sernib1
		ADD	7
sernib1:
;--------------------------------------------------
; RS232 out	208 T-States
;--------------------------------------------------
seroutfn:
		PUSH	AF
		PUSH	BC
		LD	B, A
		XOR	A
		DI
		OUT	(SEROUT), A				;startbit
		CALL	time19600				;17
	
		LD	A, B	
		LD	B, 8					;7
serout1:	
		OUT	(SEROUT), A				;11
		CALL	time19600				;17
		RRCA						;4
		DJNZ	serout1					;8
		EI	

		LD	A, 1					;7 stopbit
		OUT	(SEROUT), A				;11
		CALL	time19600				;17

		POP	BC
		POP	AF
		RET


;--------------------------------------------------
; RS232 in	208 T-States
;--------------------------------------------------
serinfn:
		PUSH	BC
serin2:
		IN	A, (SERIN)
		RLCA
		JR	C, serin2

		EX	(SP), HL				;19, 4.75uS
		EX	(SP), HL				;19  9uS

		LD	B, 80h
serin1:
		CALL	time19600
		IN	A, (SERIN)
		RLCA
		RR	B
		JR	NC, serin1

		LD	A, B
		POP	BC
		RET

time19600:
		LD	C, 9					;4
time19600a:
		DEC	C					;4
		JR	NZ, time19600a				;12/7
		RET						;10

	ENDIF
ENDIF	; SALLYBUILD

IF WD1772
SalyCMDOUT:
		OUT	(CMDREG),A				;OUTPUT DISK CONTROLLER COMMAND BYTE
slyCMDT1:
		LD	A,14
slyCMDT2:
		DEC	A
		JR	NZ,slyCMDT2				;DELAY 56 MICROSECONDS
CMDT3:
		IN	A, (STSREG)
		BIT	0, A
		JR	NZ, slyCMDT1
		RET
ENDIF

;--------------------------------------------------
; 11 times port:value
;--------------------------------------------------
INITAB:		DEFB	ATROUT,1				;SET ATART OUTPUT TO MARK STATE
		DEFB	SEROUT,1				;SET RS232 OUTPUT TO MARK STATE
		DEFB	CTC0, CTC_D1_SW_RST + CTC_D0_CONTROL	;SOFTWARE RESET CTC0
		DEFB	CTC0, low ctcvec			;SET CTC0 BASE INTERRUPT VECTOR
		DEFB	CTC1, CTC_D6_MODE_TIM + CTC_D2_TCNEXT + CTC_D1_SW_RST + CTC_D0_CONTROL	;PUT CTC1 IN TIMER MODE + SET TIME CONSTANT
		DEFB	CTC1, 1					;CTC1 TIME CONSTANT (DIVIDE BY 1 - 6.5us)
		DEFB	CTC2, CTC_D1_SW_RST + CTC_D0_CONTROL	;SOFTWARE RESET CTC2
		DEFB	CTC3, CTC_D1_SW_RST + CTC_D0_CONTROL	;SOFTWARE RESET CTC3
		DEFB	CDMUX, 1				;SET MUX TO PASS ATARI DATA
	IF WD1772
		DB	LATCH, 050h				;DRIVE CONTROL reset FDC
		DB	LATCH, 040h				;DRIVE CONTROL 8Mhz
	ELSE
		DEFB	LATCH,00000000B				;ZEROS TO DRIVE SELECT LATCH
		DEFB	CMDREG,FINCMD				;FORCE DISK CONTROLLER INTERRUPT
	ENDIF	;WD1772
ITBLEN		EQU	$-INITAB
;
;
;
;
;
;

	IF SALLYRS = 1
;
DISKTAB:			;DISK COMMANDS
	DEFW	DISKMAX

	DEFB	'R'		;DISK READ
	DEFB	'S'		;DISK STATUS
	DEFB	'W'		;DISK WRITE
	DEFB	'P'		;DISK PUT
	DEFB	'N'		;N GET PARAMETERS
	DEFB	'O'		;O PUT PARAMETERS
	DEFB	'!'		;FORMAT DISK
	DEFB	'?'		;? get speed byte
	DEFB	'"'		;" format medium density

	DEFW	diskformat
	DEFW	getspeed
;	DEFW	DISKINIT
	DEFW 	diskformat
	DEFW	PUTPARAMS
	DEFW	GETPARAMS
;	DEFW	DISKPUT
;	DEFW	DISKWRITE	
;	DEFW	DISKSTAT
;	DEFW	DISKREAD
	DEFW	diskwritefn
	DEFW	diskwritefn
	DEFW	diskstatus
	DEFW	diskreadfn
		
DISKMAX	EQU	($-(DISKTAB+2))/3

;
;
;
FMTS:
	DEFW	DD8N26		;DOUBLE DENSITY 8 INCH
	DEFW	SKEW17
	DEFB	26
	DEFW	10416

	DEFW	DD5N18		;DOUBLE DENSITY 5 INCH
	DEFW	SKEWDD
	DEFB	18
	DEFW	6250

	DEFW	SD8N26		;SINGLE DENSITY 8 INCH
	DEFW	SKEW13
	DEFB	26
	DEFW	5208

	DEFW	SD5N18		;SINGLE DENSITY 5 INCH
	DEFW	SKEWSD
	DEFB	18
	DEFW	3125
	
	DEFW	DD5N26		;DOUBLE DENSITY 128B/sec 26 secs
	DEFW	SKEWMD		;Medium or Enhanced density (ATARI 1050)
	DEFB	26
	DEFW	6500		;6238
;
;
;

DD5N26:	DEFB	1
	DEFB	50, 4EH
		
	DEFB	12
	DEFB	12,00H		;SECOND PART OF GAP 3
	DEFB	3,0F5H		;GENERATE SYNC=A1 HEX
	DEFB	1,0FEH		;GENERATE ID ADDRESS MARK
	DEFB	1,0		;TRACK#
	DEFB	1,00000000B	;SIDE
	DEFB	1,0		;SECTOR#
	DEFB	1,00000000B	;LENGTH
	DEFB	1,0F7H		;GENERATE CRC
	DEFB	22,4EH		;FIRST PART OF GAP 2
	DEFB	12,00H		;SECOND PART OF GAP 2
	DEFB	3,0F5H		;GENERATE SYNC=A1 HEX
	DEFB	1,0FBH		;GENERATE DATA ADDRESS MARK

	DEFB	3
	DEFB	1,0F7H		;GENERATE CRC BYTES
	DEFB	18,00H
	DEFB	32,4EH		;FIRST PART OF GAP 3
	
SKEWMD:	DEFB	1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25
	DEFB	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26
	
	ENDIF
	
IF SALLYBUILD

	IF SALLYRS = 0
;--------------------------------------------------
; variables and data structure
;--------------------------------------------------
;
; 32 bytes for dsktb
; 7 commands copied in from DISKTAB, 3x7=21
; 2 commands added '?' and 0xDD (setDirectSector)
;
dsktb:		DW	0, 0, 0, 0, 0, 0, 0, 0
		DW	0, 0, 0, 0, 0, 0, 0, 0
	ENDIF
;
; direct MSDOS sector for each drive
;
dsector:	DB	0, 0
direct:		DB	0

pokeydiv:	DB	SIONORMAL

drive:		DB	255
thetrack:	DB	255
secptr:		DW	0

skewtab:	DW	SKEWSD
		DW	SKEW13
		DW	SKEWDD
		DW	SKEW17

dcb:		DB	0					;DISK OPERATION CODE
		DB	0					;DRIVE# (WITH SIDE# IN BIT 7)
		DB	0					;TRACK#
		DB	0					;SECTOR#
		DW	0					;READ/WRITE POINTER
		DW	0					;AUXILLIARY PARAMETERS (2 BYTES)
		DB	0					;OPERATION COMPLETION STATUS

idambuf:
idtrack:	db	0
idside:		db	0
idsector:	db	0
idseclen:	db	0
idcrc:		dw	0

siounit:	db	0
siocmd:		db	0
siosector:	dw	0

siorc:		db	0
siobuffer:	dw	0

drivedata:
;
;
;	... DATA STRUCTURE FOR DRIVE PARAMETER BLOCKS ...
;
;NTRKS		EQU	0		;NUMBER OF TRACKS
;STEPRT		EQU	1		;STEP RATE
;NSECS		EQU	2		;SECTORS PER TRACK (HI/LOW)
;NSIDES		EQU	4		;NUMBER OF SIDES
;MEDIA		EQU	5		;MEDIA SIZE AND FORMAT BITS
;SECLEN		EQU	6		;SECTOR LENGTH (HI/LOW)
;DSKBITS	EQU	8		;MISC NAUGHTY BITS
;SPARE0		EQU	9
;SPARE1		EQU	10
;SPARE2		EQU	11
;	
;CMDSTS		EQU	12		;COMMAND STATUS
;HDWSTS		EQU	13		;HARDWARE STATUS
;	
;FLAGS		EQU	14		;FLAGS BYTE FOR DISK OPERATION
;SPARE3		EQU	15

PERCONFIG	equ	SPARE3

PERTRACK	equ 	16
PERMAXSEC	equ	17
PERSTEPRATE	equ	19
PERSKEWTAB	equ	20		;NSECS+1 bytes for sector skew

DDHD		equ	0

		org	$ + 256
		

		include	version.asm
		
		di
		ld	hl,08000h
		ld	de,00000h
		ld	bc,08000h
		ldir
		jp	RAMTST
ENDIF	;SALLYBUILD
;
;
