;	PAGE
;
;	<<< MAIN LOOP FOR ATARI DISK EMULATOR >>>
;
;
;
;
EMULATOR:
	LD	A,1
	OUT	(BANKSW),A	;TURN OFF THE ROM
;
;	CHECK TO DETERMINE WHICH CONSOLE IS ACTIVE
;
LOGON:	LD	HL,IOBUFF+LEN-2
	DI
	CALL	RXBLOCK		;LISTEN FOR A MESSAGE FROM ABOVE
	EI
	JR	NC,LOGON	;KEEP LOOPING TILL SOMETHING RECEIVED
	LD	HL,(IOBUFF+LEN-2)
	LD	DE,80E6H
	OR	A
	SBC	HL,DE
	JP	Z,MINIMON	;GOTO MONITOR IF 9600 BAUD <CR>
;
;	ENTER ATARI DISK EMULATOR MODE
;
	LD	A,3
SalyLOGN1:
	LD	(RWMAX),A	;DO LESS RETRIES IN ATARI MODE
SalyLOGN2:
	LD	A,38H		;LOAD ACC WITH 'JR C,XX' OPCODE
	LD	(KLUDGE),A	;CRIPPLE READY ERROR FROM 'SELECT'
	IN	A,(SERIN)
	BIT	3,A
	JR	NZ,HAS850	;JUMP IF 850 JUMPER PRESENT

	LD	A,255
	LD	(PTRID),A	;ELSE ZAP PRINTER ID IN TABLE

HAS850:	LD	HL,DUMMY
	LD	(RENEW+1),HL	;MAKE DUMMY CONSOLE RE-INIT VECTOR
	LD	DE,(RENEW+1-0C000H)
	OR	A
	SBC	HL,DE
	JR	Z,MAIN		;JUMP IF 16K MEMORY SIZE MACHINE

IF SALLYBUILD
	LD	HL, 02200h	;was 0000h, now 0800h+26*256 track buffer = 2200h
	LD	(PBASE),HL	;ELSE SETUP FOR 39.5K PRINTER BUFFER
	LD	HL,09DFFH	;bfffh - 2200h = 9dffh	
ELSE
	LD	HL,0
	LD	(PBASE),HL	;ELSE SETUP FOR 48K PRINTER BUFFER
	LD	HL,0BFFFH
ENDIF	;SALLYBUILD
	LD	(PSIZE),HL

MAIN:	CALL	SPOOLER		;KEEP BACKGROUND PRINTING GOING
	LD	HL,(FSMVEC)
	CALL	CALLHL		;DO ATARI TASK ROUTINE
	LD	HL,(EXTVEC)
	CALL	CALLHL		;DO EXTRA TASK ROUTINE
	JR	MAIN
;
;
CALLHL:	JP	(HL)
;
;
;
PWRWAIT:
	IN	A,(ATARI)
	AND	10001010B	;MASK TO DATA/POWER/COMMAND BITS
	CP	10001010B
	RET	NZ

	DI
	XOR	A
	LD	(CMDFLG),A	;RESET COMMAND FRAME FLAG
	OUT	(CDMUX),A	;SET MUX TO GATE COMMAND LINE TO CTC0
	LD	A,CTC_D7_INT_EN + CTC_D6_MODE_CNT + CTC_D4_RISEEDGE + CTC_D2_TCNEXT + CTC_D1_SW_RST + CTC_D0_CONTROL	; Set up values for CTC0
	OUT	(CTC0),A	;RESET CTC AND ARM FOR HIGH->LOW IRQ
	LD	A,1			;TIME CONSTANT OF 1
	OUT	(CTC0),A	;WRITE TIME CONSTANT
	LD	HL,CSTART
	LD	(CTCVEC),HL	;STORE INTERRUPT VECTOR
	EI
	LD	HL,CMDWAIT
	LD	(FSMVEC),HL	;SET FSM VECTOR TO 'CMDHIGH' STATE
DUMMY:	RET
;
;
;
CMDWAIT:
	LD	A,(CMDFLG)
	OR	A			;SEE IF COMMAND FRAME HAS ARRIVED
	RET	Z			;EXIT IF NOTHING HAS HAPPENED

	CP	1
	JR	Z,CMDL4		;PROCESS COMMAND IF GOOD FRAME RECVD

	DI				;ELSE RESET INTERRUPT AND START AGAIN
	LD	A, CTC_D1_SW_RST + CTC_D0_CONTROL	; SOFTWARE RESET CTC0
	OUT	(CTC0),A	;PERFORM THE RESET
	EI
	JR	CMDL5		;GO SET FSM VECTOR
;
;
CFRAME	EQU	IOBUFF+LEN-5	;COMMAND FRAME IS LAST 5 BYTES OF BUFF
;
CMDL4:	LD	A,(CFRAME)
	LD	HL,(IDPTR)	;GET POINTER TO ID CODE TABLE
	CALL	SCAN		;SCAN TABLE FOR MATCHING UNIT ID CODE
	JR	NZ,CMDL5	;EXIT IF COMMAND IS NOT FOR US

	LD	A,(CFRAME+1)
	CALL	SCAN		;SCAN FOR COMMAND CODE IN TABLE
	JR	NZ,CMDL5	;ERROR IF NO MATCH FOUND

	CALL	CALLHL		;GO TO COMMAND PROCESSOR @HL
;
CMDL5:	LD	HL,PWRWAIT
	LD	(FSMVEC),HL	;SET FSM VECTOR BACK TO IDLE STATE
	RET
;
;
;
;
SCAN:
	LD	C,(HL)		;LOAD BC WITH TABLE LENGTH @HL
	INC	HL
	LD	B,(HL)
	INC	HL
	CPIR			;SCAN STRING @HL FOR MATCH WITH ACC
	RET	NZ		;EXIT IF NO MATCH

	PUSH	AF
	ADD	HL,BC		;ELSE ADD RESIDUE FROM CPIR TO HL
	ADD	HL,BC		; THREE TIMES TO POINT TO ADDRESS
	ADD	HL,BC		; CORRESPONDING TO MATCHED VALUE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	POP	AF
	RET			;RETURN TABLE ENTRY IN HL
;
;
;
;	... DEVICE ID TABLE FOR DISK/PRINTER/RS232 COMBO BOX ...
;
IDTAB:
	DEFW	IDMAX

PTRID:	DEFB	'@'		;PRINTER CONTROLLER ID CODE
	DEFB	'1'		;DISK UNIT #1 ID CODE
	DEFB	'2'		;DISK #2
	DEFB	'3'		;DISK #3
	DEFB	'4'		;DISK #4
	DEFB	'Z'		;Z80 LOAD/DUMP/GOTO

	DEFW	Z80TAB
SalyDISKID:
	DEFW	DISKTAB
	DEFW	DISKTAB
	DEFW	DISKTAB
	DEFW	DISKTAB
	DEFW	PTRTAB
IDMAX	EQU	($-IDTAB)/3
;
;
;
PTRTAB:				;PRINTER COMMANDS
	DEFW	PTRMAX

	DEFB	'S'		;PRINTER STATUS
	DEFB	'W'		;PRINTER OUTPUT

	DEFW	PTRWRITE
	DEFW	PTRSTAT
PTRMAX	EQU	($-(PTRTAB+2))/3
;
;
;
DISKTAB:			;DISK COMMANDS
	DEFW	DISKMAX

	DEFB	'R'		;DISK READ
	DEFB	'S'		;DISK STATUS
	DEFB	'W'		;DISK WRITE
	DEFB	'P'		;DISK PUT
	DEFB	'N'		;GET PARAMETERS
	DEFB	'O'		;PUT PARAMETERS
	DEFB	'!'		;FORMAT DISK

	DEFW	DISKINIT
	DEFW	PUTPARAMS
	DEFW	GETPARAMS
	DEFW	DISKPUT
	DEFW	DISKWRITE
	DEFW	DISKSTAT
	DEFW	DISKREAD
DISKMAX	EQU	($-(DISKTAB+2))/3
;
;
;
Z80TAB:				;Z80 COMMANDS
	DEFW	Z80MAX

	DEFB	'R'		;MEMORY READ
	DEFB	'W'		;MEMORY WRITE
	DEFB	'S'		;SET ADDRESS
	DEFB	'G'		;GOTO ADDRESS

	DEFW	Z80GOTO
	DEFW	Z80SET
	DEFW	Z80WRITE
	DEFW	Z80READ
Z80MAX	EQU	($-(Z80TAB+2))/3
;
;
;
	PAGE
;
;
;	... PRINTER STATUS COMMAND PROCESSOR ...
;
PTRSTAT:
	CALL	SENDACK
	LD	HL,PSMSG
	LD	DE,IOBUFF+LEN-4
	PUSH	DE
	LD	BC,4
	LDIR			;COPY PRINTER STATUS FRAME FROM RAM
	POP	HL
	LD	DE,'C'		;SEND PRINTER STATUS UN-INVERTED
	JP	SENDBUFF
;	ret
;
;
;	... PRINTER WRITE COMMAND PROCESSOR ...
;
PTRWRITE:
	CALL	SENDACK		;SEND 'ACK' FOR COMMAND FRAME
	CALL	RECVBUFF	;GET PRINT DATA FROM SERIAL BUS
	RET	NZ		;EXIT IF ERROR OR TIMEOUT

	LD	DE,40
	OR	A
	SBC	HL,DE
	RET	NZ		;ERROR IF RX BLOCK LENGTH <> 40 BYTES

	CALL	SENDACK		;ELSE SEND 'ACK'
	LD	HL,IOBUFF
	LD	B,40
PWRIT3:	LD	A,(HL)
	CP	9BH		;CHECK FOR 'ATASCII' CARRIAGE RETURN
	JR	NZ,PWRT3A

	LD	HL,NEWLIN
	LD	B,(HL)		;OUTPUT PRINTER'S NEWLINE CHARACTER(S)
	INC	HL

PWRT3A:	PUSH	HL
	LD	HL,(PCOUNT)
	LD	DE,(PSIZE)
	OR	A
	SBC	HL,DE		;TEST IF PRINTER BUFFER IS FULL
	POP	HL
	JR	C,PWRIT4	;STORE ANOTHER CHARACTER IF NOT FULL

	PUSH	HL
	PUSH	BC
	CALL	SPOOLER		;TRY TO CLEAR OUT BUFFER
	POP	BC
	POP	HL
	IN	A,(ATARI)
	AND	00000010B	;TEST ATARI COMMAND LINE AND
	JR	NZ,PWRT3A	;STAY IN LOOP IF INACTIVE

	RET			;ELSE ABORT PRINTING AND RETURN
;
PWRIT4:	LD	A,(HL)
	INC	HL
	PUSH	HL
	PUSH	BC
	LD	HL,(PINP)
	CALL	INDEX		;GET INDEX TO FIFO INPUT PLACE
	LD	(PINP),DE	;STORE UPDATED INPUT OFFSET
	LD	(HL),A		;STORE CHARACTER IN QUEUE
	LD	HL,(PCOUNT)
	INC	HL		;BUMP FIFO CHARACTER COUNTER
	LD	(PCOUNT),HL
	POP	BC
	POP	HL
	DJNZ	PWRIT3		;REPEAT TO END OF STRING

	JP	SENDCOMP	;SEND 'COMPLETE' TO ATARI
;	ret
;
;
;
SPOOLER:
	LD	HL,(PCOUNT)
	LD	A,H
	OR	L
	RET	Z		;EXIT IF NO DATA IN FIFO TO PRINT

	CALL	LISTV+3
	RET	NZ		;EXIT IF PRINTER BUSY

	LD	HL,(POUT)
	CALL	INDEX		;GET POINTER WITH AUTO-INCREMENT
	LD	(POUT),DE
	LD	C,(HL)
	CALL	LISTV		;PRINT CHARACTER AND EXIT
	LD	HL,(PCOUNT)
	DEC	HL		;DIMINISH BUFFER COUNT BY ONE
	LD	(PCOUNT),HL
	RET
;
;
;
;
INDEX:
	EX	DE,HL
	LD	HL,(PBASE)
	ADD	HL,DE		;ADD OFFSET TO FIFO BASE ADDRESS
	PUSH	HL
	INC	DE		;BUMP OFFSET NOW IN DE
	LD	HL,(PSIZE)
	OR	A
	SBC	HL,DE		;COMPARE TO MAX OFFSET VALUE
	JR	NC,INDEX2
	LD	DE,0		;SET OFFSET TO ZERO IF ROLL-OVER
INDEX2:	POP	HL
	RET			;RETURN DE=OFFSET AND HL=POINTER
;
;
;
;	... DISK WRITE COMMAND PROCESSOR ...
;
DISKPUT:
	XOR	A
	JR	DWRT0
;
DISKWRITE:
	LD	A,1
DWRT0:	LD	(VFLAG),A
	CALL	DRVINDEX	;INDEX TO GET DRIVE PARAMETER POINTER
	RET	C		;EXIT IF NOT A DRIVE IN OUR BOX

	CALL	SENDACK
	CALL	RECVBUFF	;ELSE GO QUICK TO READ DATA FRAME
	RET	NZ		;EXIT IF BAD CHECKSUM
SalyDISKWRT1:
	LD	(LOGSIZ),HL	;SAVE DATA BLOCK LENGTH
SalyDISKWRT2:
	LD	DE,128
	OR	A
	SBC	HL,DE		;TEST FOR 128 BYTE FRAME
	JR	Z,DWRT1
	OR	A
	SBC	HL,DE		;TEST FOR 256 BYTE FRAME
	RET	NZ

DWRT1:	CALL	SENDACK		;SEND 'ACK' IF BLOCKSIZE IS 128 OR 256
	CALL	SECTRAN		;SET DISK PARAMETERS FOR WRITE
	JR	NZ,DWRT4	;JUMP IF ERROR FROM 'SECTRAN'

	LD	HL,IOBUFF
	LD	(DKIOCB+DSKPTR),HL
	LD	A,(LOGSIZ)
	LD	B,A		;PREPARE TO COMPLIMENT DISK DATA BLOCK
DWRT2:	LD	A,(HL)
	CPL
	LD	(HL),A		;COMPLIMENT DISK DATA BLOCK
	INC	HL
	DJNZ	DWRT2		;REPEAT TO END OF BLOCK
	LD	A,PUTSEC
	LD	(DKIOCB+DSKOP),A
	LD	IX,DKIOCB
SalyDISKWRT3:
	CALL	DISKV		;CALL PHYSICAL DISK DRIVER
	LD	A,(DKIOCB+DSKSTS)
	OR	A
	JR	NZ,DWRT4	;BOMB OUT NOW IF DISK ERROR

	LD	A,(VFLAG)
	OR	A
	JR	Z,DWRT4		;EXIT OK IF NOT WRITE WITH VERIFY

	LD	A,GETSEC
	LD	(DKIOCB+DSKOP),A
	LD	HL,IOBUFF+LEN
	LD	(DKIOCB+DSKPTR),HL
	CALL	DISKV		;ELSE READ SECTOR BACK FOR VERIFY
	LD	A,(DKIOCB+DSKSTS)
	OR	A
	JR	NZ,DWRT4	;BOMB AGAIN IF READ ERROR

	LD	HL,IOBUFF
	LD	DE,IOBUFF+LEN
	LD	A,(DKIOCB+DSKAUX)
	LD	B,A		;PREPARE TO COMPARE 128 OR 256 BYTES
DWRT3:	LD	A,(DE)
	XOR	(HL)
	JR	NZ,DWRT5
	INC	HL
	INC	DE
	djnz	DWRT3		;fall through last time with acc=0

DWRT4:	CALL	SETSTAT		;DO STATUS SETTING STUFF
	LD	A,E
	JP	SENDCHAR	;SEND 'COMPLETE' OR 'ERROR' TO ATARI
;	ret
;
DWRT5:	XOR	A
	CALL	ssts4		;set hardware status=0 but set bad r/w
	LD	a,e
	JP	sendchar
;	ret
;
;
;
;	... DISK READ COMMAND PROCESSOR ...
;
DISKREAD:
	CALL	DRVINDEX	;POINT IY TO DRIVE'S DATA AREA
	RET	C		;EXIT IF NOT A DRIVE IN OUR BOX

	CALL	SENDACK
SalyDISKRD1:
	CALL	SECTRAN		;SET PARAMETERS FOR DISK OPERATION
SalyDISKRD2:
	PUSH	AF		;SAVE ERROR STATUS FROM 'SECTRAN'
	JR	Z,DRD2		;JUMP IF PARAMS SET OK

	LD	D,(IY+SECLEN)
	LD	E,(IY+SECLEN+1)	;LOAD DE WITH SECTOR LEN FROM 'DMATRIX'
	LD	A,D
	OR	E
	JR	NZ,DRD2A	;JUMP IF LENGTH <> 0

	LD	DE,128		;ELSE REVERT TO 128 BYTES
	JR	DRD2A
;
DRD2:	LD	DE,(DKIOCB+DSKAUX) ;LOAD DE WITH PHYSICAL SECTOR LENGTH
DRD2A:	LD	HL,(CFRAME+2)
	LD	BC,4
	OR	A
	SBC	HL,BC		;TEST IF ACCESSING SECTOR# 1,2 OR 3
	JR	NC,DRD3		;JUMP IF NOT ACCESSING A BOOT SECTOR
	LD	DE,128
DRD3:	LD	(LOGSIZ),DE
	LD	HL,IOBUFF+LEN
	OR	A
	SBC	HL,DE		;COMPUTE STARTING PLACE IN BUFFER
	POP	AF
	JR	NZ,DRD4		;JUMP IF ERROR FROM 'SECTRAN' ABOVE

	LD	(DKIOCB+DSKPTR),HL
	LD	A,GETSEC
	LD	(DKIOCB+DSKOP),A
	LD	IX,DKIOCB
	PUSH	HL
SalyDISKRD3:
	CALL	DISKV		;CALL DISK I/O HANDLER
	POP	HL
	LD	A,(DKIOCB+DSKSTS)

DRD4:	CALL	SETSTAT		;TEST AND STORE STATUS STUFF
	LD	D,255		;SET MASK TO INVERT DISK DATA
	JP	SENDBUFF	;SEND RESPONSE TO ATARI
;	ret
;
;
;
;	ROUTINE TO CHECK STATUS AFTER READ/WRITE
;
SETSTAT:
	OR	A
	JR	NZ,SSTS1	;JUMP IF SOME DISK ERROR INDICATED

	LD	(IY+HDWSTS),A	;ELSE STORE ZEROS IN HARDWARE STATUS
	LD	E,'C'		;LOAD E WITH 'COMPLETE' CHARACTER
	RES	BADRW,(IY+CMDSTS)
	RET
;
;	ACC HOLDS NON-ZERO VALUE INDICATING A DISK ERROR
;
SSTS1:	BIT	6,A		;BIT HOLDS WPROT STATUS AFTER WRITE
	JR	Z,SSTS2

	AND	10011111B

SSTS2:	BIT	5,A		;HOLDS DD MARK STATUS AFTER READ
	JR	Z,SSTS3

	OR	01100000B	;CREATE 1771 DD ADDRESS MARK STATUS

SSTS3:	LD	C,A
	AND	10000001B	;TEST FOR 'READY' OR 'BUSY' BITS SET
	LD	A,C
	JR	Z,SSTS4		;JUMP IF NOT READY/BUSY LOCK UP

	AND	01111110B	;ELSE CLEAR BOTH BITS AND REPLACE
	OR	00010000B	; WITH 'RNF' ERROR BIT INSTEAD

SSTS4:	LD	(IY+HDWSTS),A	;STORE HARDWARE STATUS FOR ATARI
	LD	E,'E'		;LOAD E WITH 'ERROR' CHARACTER
	SET	BADRW,(IY+CMDSTS)
	RET
;
;
;
;
;
;
SECTRAN:
;	BIT	CONFIG,(IY+FLAGS)
;	JP	NZ,STRAN3	;SKIP IF DRIVE HAS BEEN CONFIGURED

	LD	A,(DRVOFF)
	OR	A
	JR	Z,STRAN2	;JUMP IF DRIVES HAVE NOT BEEN STOPPED

	XOR	A
	LD	(DRVOFF),A	;CLEAR DRIVES-STOPPED FLAGS
	LD	HL,DMATRIX+FLAGS
	LD	DE,16
	LD	B,4
STRAN1:	RES	FIRST,(HL)	;ZIP THRU ARRAY RESETING 'FIRST' FLAGS
	ADD	HL,DE		; TO FORCE MEDIA TO BE EXAMINED ANEW
	DJNZ	STRAN1

STRAN2:	BIT	FIRST,(IY+FLAGS)
	JR	NZ,STRAN3	;SKIP MEDIA CHECK IF DRIVE IS ACTIVE

	LD	A,GETID
	LD	(DKIOCB+DSKOP),A
	LD	A,(DKIOCB+DSKDRV)
	LD	HL,DRVTAB
	ADD	A,L
	LD	L,A		;POINT TO HEAD POSITION FOR DRIVE#
	LD	A,(HL)
	CP	80
	JR	C,STR20		;JUMP IF TRACK# IN VALID RANGE
	XOR	A		;ELSE GOTO TRACK ZERO
STR20:	LD	(DKIOCB+DSKTRK),A
	LD	HL,IDBUF
	LD	(DKIOCB+DSKPTR),HL
	LD	IX,DKIOCB
	CALL	DISKV		;READ AN ID MARK FROM CURRENT TRACK
	LD	A,(DKIOCB+DSKSTS)
	OR	A
	RET	NZ		;EXIT IF DISK ERROR ON READ-ID
;
;	ARRIVE HERE TO SET DISK PARAMS IMPLICITLY
;
	LD	A,(IDBUF+3)	;GET SECTOR LENGTH BYTE FROM ID
	call	getsize		;compute sector length in bytes
	ld	(iy+seclen),b
	ld	(iy+seclen+1),c	;store result in 'seclen' param slot
	LD	A,(DKIOCB+DSKAUX)
	RLCA
	RLCA
	RLCA
	CPL
	AND	00000110B	;MAKE PERCOM DENSITY/SIZE BITS
	LD	(IY+MEDIA),A
	BIT	SIZE,A
	JR	Z,STR25		;JUMP IF FIVE INCH DISK SELECTED

	LD	A,77
	LD	HL,26
	JR	STR26
;
STR25:	LD	A,40
	LD	HL,18
str26:	cp	(iy+ntrks)
	jr	c,str27		;skip if ntrks has been set > default
	ld	(iy+ntrks),a	;else set param to default value
STR27:	LD	(IY+NSECS),H
	LD	(IY+NSECS+1),L	;STORE SECTORS PER TRACK PARAM

	SET	FIRST,(IY+FLAGS)
	LD	HL,(OLDPTR)
	LD	A,H
	OR	L
	JR	NZ,STRAN3	;JUMP IF NOT THE FIRST-EVER DISKOP

	LD	(OLDPTR),IY	;ELSE SET POINTER TO THIS GUYS STUFF
;
;	ARRIVE HERE TO COMPUTE TRACK/SECTOR AND SET DISK BYTECOUNT
;
STRAN3:	LD	HL,(CFRAME+2)
	DEC	HL		;REMOVE +1 BIAS FROM SECTOR NUMBER
	LD	D,0
	LD	E,(IY+NSECS+1)
	LD	A,-1
STRAN4:	INC	A
	OR	A
	SBC	HL,DE
	JR	NC,STRAN4	;DIVIDE ABSOLUTE SECTOR NUMBER BY SPT
	ADD	HL,DE
	INC	HL		;RESTORE +1 BIAS TO SECTOR NUMBER
	LD	C,L
	LD	HL,DKIOCB+DSKSEC
	LD	(HL),C		;STORE PHYSICAL SECTOR#

	CP	(IY+NTRKS)	;COMPARE RESULT FROM TRACK# COMPUTATION
	JR	C,STRAN5	; TO 'NTRKS' PARAM AND JUMP IF LESS

	SUB	(IY+NTRKS)	;ELSE SUBTRACT EXTRA AND SELECT SIDE# 1
	LD	HL,DKIOCB+DSKDRV
	SET	7,(HL)

STRAN5:	LD	(DKIOCB+DSKTRK),A  ;STORE PHYSICAL TRACK#
	LD	H,(IY+SECLEN)
	LD	L,(IY+SECLEN+1)
	LD	(DKIOCB+DSKAUX),HL  ;STORE PHYSICAL SECTOR SIZE FOR I/O
	XOR	A
	RET
;
;
;
getsize:
	ld	bc,128
	and	00000011b
	ret	z		;sector length code=0 means 128 bytes

getsz2:	sla	c
	rl	b		;else multiply 128 by 2,4 or 8
	dec	a
	jr	nz,getsz2
	ret
;
;
;
;
;
;	... DISK STATUS COMMAND PROCESSOR ...
;
DISKSTAT:
	CALL	DRVINDEX	;POINT IY TO DRIVE'S DATA AREA
	RET	C		;EXIT IF NOT A DRIVE IN OUR BOX

	CALL	SENDACK		;SEND 'ACK' FOR COMMAND FRAME
	CALL	HASPARMS	;CHECK IF HAS NEVER BEEN ACCESSED
	LD	A,(DRVTMR)
	PUSH	AF		;SAVE DRIVE TIMER VALUE RIGHT NOW
	LD	A,TSTRDY
	LD	(DKIOCB+DSKOP),A
	LD	IX,DKIOCB
	CALL	DISKV		;CALL DISK HANDLER TO GET TYPE 1 STATUS

	LD	C,(IY+CMDSTS)	;PREPARE TO DERRIVE REST OF 'CMDSTS'
	LD	(IY+CMDSTS),0	; AND RESET OLD STATUS BITS
	POP	AF
	OR	A
	JR	Z,DSTAT1	;JUMP IF DRIVES WERE PREVIOUSLY STOPPED

	SET	ACTIVE,C
	JR	DSTAT2
;
DSTAT1:	RES	ACTIVE,C
DSTAT2:	BIT	DENSTY,(IY+MEDIA)
	JR	Z,DSTAT3	;JUMP IF DRIVE SET FOR SINGLE DENSITY

	SET	SEC256,C
	JR	DSTAT4
;
DSTAT3:	RES	SEC256,C
DSTAT4:	BIT	6,(IX+DSKSTS)
	JR	Z,DSTAT5	;JUMP IF DRIVE IS NOT WRITE PROTECTED

	SET	WRPROT,C
	JR	DSTAT6
;
DSTAT5:	RES	WRPROT,C
DSTAT6:	LD	HL,IOBUFF+LEN-4
	PUSH	HL
	LD	(HL),C		;STORE DRIVE COMMAND STATUS IN BUFFER
	INC	HL
	LD	A,(IY+HDWSTS)
	CPL
	LD	(HL),A		;STORE HARDWARE POOP NEXT
	INC	HL
	LD	(HL),224	;STORE MAX TIMEOUT AFTER THAT
	INC	HL
	LD	A,(TRACK)
	LD	(HL),A		;STORE TRACK# AS FOURTH BYTE
	POP	HL
	LD	DE,'C'		;SEND DISK STATUS W/O COMPLIMENT
	JP	SENDBUFF
;	ret
;
;
;
;	... DISK FORMAT COMMAND PROCESSOR ...
;
DISKINIT:
	CALL	DRVINDEX	;POINT IY TO DRIVE'S DATA AREA
	RET	C		;EXIT IF NOT A DRIVE IN OUR BOX

	LD	HL,(PCOUNT)
	LD	A,H
	OR	L
	RET	NZ		;REFUSE TO FORMAT IF SPOOLER ACTIVE

	CALL	HASPARMS
	RET	Z		;REFUSE TO FORMAT IF PARAMS NOT SET

	CALL	SENDACK
	LD	A,TSTRDY
	LD	(DKIOCB+DSKOP),A
	LD	IX,DKIOCB
	CALL	DISKV		;CALL DRIVER TO TEST READY/WRITE PROT
	CALL	STOPTMR		;THEN KILL CTC3 TO STOP DISK TIMER
	LD	A,(OUTCPY)
	BIT	DENSTY,(IY+MEDIA)
	JR	Z,DINIT2

	RES	7,A		;RESET DENSITY BIT OF CONTROL BYTE
	LD	HL,IOBUFF+LEN-256
	JR	DINIT3
;
DINIT2:	SET	7,A		;SET SD/DD BIT IF SINGLE DENSITY
	LD	HL,IOBUFF+LEN-128
DINIT3:	LD	(OUTCPY),A
	OUT	(LATCH),A
	PUSH	HL
	LD	(SEQPTR),HL	;STORE POINTER FOR BAD SECTOR LIST
	LD	HL,1
	LD	(SEQNUM),HL	;RESET BAD SECTOR COUNTER
	LD	HL,(FMTPTR)
	LD	DE,FMTSTUFF
	LD	BC,FMTLEN
	RLCA
	RLCA
	AND	00000011B
	JR	Z,SFMT3
SFMT2:	ADD	HL,BC
	DEC	A
	JR	NZ,SFMT2	;INDEX TO PROPER PARAMS FOR DISK TYPE
SFMT3:	LDIR			;THEN COPY PARAMS TO 'FMTSTUFF'
	LD	A,(DKIOCB+DSKSTS)
	AND	11000000B
	JR	NZ,DINIT6	;ERROR IF NOT READY OR WRITE PROTECTED

	ld	a,(iy+nsides)	;set for SS/DS init
	ld	(sides),a
	ld	a,(iy+ntrks)	;set for number of tracks
	ld	(tracks),a
	PUSH	IY
	CALL	FORMAT		;CALL FORMAT SUBROUTINE
	POP	IY

DINIT6:	POP	HL
	CALL	SETSTAT		;UPDATE STATUS AS SPECIFIED BY ACC
	LD	D,0
	CALL	SENDBUFF	;SEND BAD SECTOR DATA FRAME
	JP	ACTIVON		;THEN RESTART THE DISK TIMER
;	ret
;
;
;
;
;
FMTS:
	DEFW	DD8N26		;DOUBLE DENSITY 8 INCH
	DEFW	SKEW17
	DEFB	26
	DEFW	10416

	DEFW	DD5N18		;DOUBLE DENSITY 5 INCH
	DEFW	SKEWDD
	DEFB	18
	DEFW	6250

	DEFW	SD8N26		;SINGLE DENSITY 8 INCH
	DEFW	SKEW13
	DEFB	26
	DEFW	5208

	DEFW	SD5N18		;SINGLE DENSITY 5 INCH
	DEFW	SKEWSD
	DEFB	18
	DEFW	3125
;
;
;
;
HASPARMS:
	LD	A,(IY+NTRKS)
	OR	A
	RET	NZ		;EXIT IF PARAMS HAVE BEEN SET

	LD	HL,(OLDPTR)
	LD	A,H		;IF POINTER IS ZERO THEN NO DRIVE
	OR	L		; PARAMS HAVE EVER BEEN SET
	RET	Z

	PUSH	IY
	POP	DE
	LD	BC,12
	LDIR			;COPY BOOT DISK'S PARAMS TO THIS GUY
	RET
;
;
;
;
;	... PERCOM 'N' COMMAND PROCESSOR ...
;
GETPARAMS:
	CALL	DRVINDEX	;POINT IY TO DRIVE'S DATA AREA
	RET	C		;EXIT IF NOT A DRIVE IN OUR BOX

	CALL	HASPARMS
	RET	Z		;EXIT IF DISK PARAMS NOT KNOWN

	CALL	SENDACK		;SEND 'ACK' FOR COMMAND FRAME
;	SET	CONFIG,(IY+FLAGS)
	PUSH	IY
	POP	HL
	LD	DE,IOBUFF+LEN-12
	PUSH	DE
	LD	BC,12
	LDIR			;COPY PARAMS TO OUTPUT BUFFER
	POP	HL
	LD	DE,'C'
	JP	SENDBUFF	;SEND 'C' AND PARAMS DATA FRAME
;	ret
;
;
;
;	... PERCOM 'O' COMMAND PROCESSOR ...
;
PUTPARAMS:
	CALL	DRVINDEX	;POINT IY TO DRIVE'S DATA AREA
	RET	C		;EXIT IF NOT A DRIVE IN OUR BOX

	CALL	SENDACK
	CALL	RECVBUFF	;ATTEMPT TO READ DATA FRAME FROM ATARI
	RET	NZ

	LD	DE,12
	OR	A
	SBC	HL,DE
	RET	NZ		;ERROR IF DATA FRAME NOT 12 BYTES

	CALL	SENDACK		;ELSE SEND 'ACK' FOR DATA FRAME
;	SET	CONFIG,(IY+FLAGS)  ;INDICATE DRIVE IS NOW CONFIGURED
	LD	HL,IOBUFF
	PUSH	IY
	POP	DE		;POINT DE TO PARAMETERS FOR DRIVE(N)
	LD	BC,12
	LDIR			;COPY NEW STUFF IN THE PLACE
	JP	SENDCOMP	;SEND 'COMPLETE' BACK TO ATARI
;	ret
;
;
;
;	... DATA STRUCTURE FOR DRIVE PARAMETER BLOCKS ...
;
NTRKS	EQU	0		;NUMBER OF TRACKS
STEPRT	EQU	1		;STEP RATE
NSECS	EQU	2		;SECTORS PER TRACK (HI/LOW)
NSIDES	EQU	4		;NUMBER OF SIDES
MEDIA	EQU	5		;MEDIA SIZE AND FORMAT BITS
SECLEN	EQU	6		;SECTOR LENGTH (HI/LOW)
DSKBITS	EQU	8		;MISC NAUGHTY BITS
SPARE0	EQU	9
SPARE1	EQU	10
SPARE2	EQU	11

CMDSTS	EQU	12		;COMMAND STATUS
HDWSTS	EQU	13		;HARDWARE STATUS

FLAGS	EQU	14		;FLAGS BYTE FOR DISK OPERATION
SPARE3	EQU	15
;
;
;	EQUATES FOR BITS IN 'MEDIA' BYTE
;
SIZE	EQU	1		;DISK SIZE (1=EIGHT, 0=FIVE)
DENSTY	EQU	2		;DENSITY (1=DOUBLE, 0=SINGLE)
;
;
;	EQUATES FOR BITS IN 'DSKBITS' BYTE
;
PRESENT	EQU	6		;DRIVE PRESENT (1=PRESENT)
;
;
;	EQUATES FOR BITS IN 'CMDSTS' BYTE
;
BADCMD	EQU	0		;BAD COMMAND FRAME BIT
BADDAT	EQU	1		;BAD DATA FRAME BIT
BADRW	EQU	2		;BAD READ/WRITE OPERATION BIT
WRPROT	EQU	3		;WRITE PROTECTED BIT
ACTIVE	EQU	4		;DRIVE READY INDICATOR BIT
SEC256	EQU	5		;LONG/SHORT SECTOR BIT
;
;
;	EQUATES FOR BITS IN 'FLAGS' BYTE
;
FIRST	EQU	0		;FIRST ACCESS FLAG (0=NOT ACCESSED)
CONFIG	EQU	1		;DRIVE CONFIGURED BIT (0=UNCONFIGED)
;
;
;
;
;
DRVINDEX:
	LD	A,(CFRAME)	;GET DRIVE# FROM COMAND FRAME
	SUB	'1'
	CP	4
	CCF
	RET	C		;EXIT IF NOT DRIVE 1,2,3 OR 4

	LD	H,0
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL		;MULTIPLY DRIVE INDEX BY 16
	LD	BC,DMATRIX
	ADD	HL,BC		;INDEX TO DRIVE'S PARAMETERS
	PUSH	HL
	POP	IY		;GET POINTER INTO IY FOR RETURN
	BIT	PRESENT,(IY+DSKBITS)
	SCF
	RET	Z		;EXIT IT DRIVE NOT PRESENT

	LD	(DKIOCB+DSKDRV),A
	XOR	A
	RET
;
;
;
;
SENDACK:
	IN	A,(ATARI)
	BIT	1,A
	JR	Z,SENDACK

	LD	A,'A'
	JR	SENDCHAR
;
SENDCOMP:
	LD	A,'C'
SENDCHAR:
	LD	HL,IOBUFF+LEN+1
	LD	(HL),A
	LD	D,0		;SET FOR TRUE DATA
	JP	XMITBUF		;SEND 1 BYTE BLOCK TO ATARI
;	ret
;
;
;
;
;	... Z80 MEMORY READ COMMAND PROCESSOR ...
;
Z80READ:
	CALL	SENDACK		;SEND 'ACK' FOR COMMAND
	CALL	ZLENGTH		;GET ZCMD BYTECOUNT INTO BC
	LD	HL,IOBUFF+LEN
	OR	A
	SBC	HL,BC
	PUSH	HL
	EX	DE,HL
	LD	HL,(MEMPTR)
	DI
	LDIR			;DO BLOCK MOVE INTO BUFFER
	EI
	POP	HL
	LD	DE,'C'		;SEND DATA W/O INVERSION
	JP	SENDBUFF
;	ret
;
;
;
;	... Z80 MEMORY WRITE COMMAND PROCESSOR ...
;
Z80WRITE:
	CALL	SENDACK		;SEND 'ACK' FOR COMMAND FRAME
	CALL	RECVBUFF	;ATTEMPT TO READ DATA FRAME FROM ATARI
	RET	NZ

	CALL	ZLENGTH		;GET BYTECOUNT FROM CMD FRAME
	OR	A
	SBC	HL,BC
	RET	NZ		;ERROR IF DATA FRAME LENGTH NOT SAME

	PUSH	BC
	CALL	SENDACK		;ELSE SEND 'ACK' FOR DATA FRAME
	POP	BC
	LD	HL,IOBUFF
	LD	DE,(MEMPTR)
	DI
	LDIR			;DO BLOCK MOVE INTO BUFFER
	EI
	JP	SENDCOMP	;SEND 'COMPLETE' BACK TO ATARI
;	ret
;
;
;
ZLENGTH:
	LD	A,(CFRAME+2)	;GET BYTECOUNT FROM COMMAND FRAME
	LD	C,A
	LD	B,0		;LOAD BC WITH BYTECOUNT
	OR	A
	RET	NZ		;EXIT IF BYTECOUNT NOT=0

	INC	B		;ELSE MAKE BC=256
	RET
;
;
;	... Z80 SET MEMORY POINTER COMMAND PROCESSOR ...
;
Z80SET:
	CALL	SENDACK
	LD	HL,(CFRAME+2)	;SET MEMORY POINTER FROM COMMAND
	LD	(MEMPTR),HL
	JP	SENDCOMP
;	ret
;
;
MEMPTR:	DEFW	0		;POINTER FOR MEMORY READ/WRITE
;
;
;	... Z80 GOTO MEMORY LOCATION COMMAND PROCESSOR ...
;
Z80GOTO:
	CALL	SENDACK
	CALL	SENDCOMP
	LD	HL,(CFRAME+2)
	jp	(hl)		;execute routine @hl
;
;
;
;
