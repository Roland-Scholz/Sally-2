;********************************************************
;*							*
;*	DISK I/O DRIVER FOR ATARI BOX.	18-FEB-82	*
;*							*
;********************************************************
;
;
;	EQUATES FOR DISK CONTROLLER PORTS AND COMMAND CODES
;
STSREG	EQU	WD179X+0	;STATUS REGISTER
CMDREG	EQU	WD179X+0	;COMMAND REGISTER
TRKREG	EQU	WD179X+1	;TRACK REGISTER
SECREG	EQU	WD179X+2	;SECTOR REGISTER
DATREG	EQU	WD179X+3	;DATA REGISTER
;
;	TYPE I COMMANDS LOW NIBBLE
;
STEPRATE0	EQU 0		;6ms,  3 ms if 179x and 2 MHz
STEPRATE1	EQU 1		;12ms, 6 ms if 179x and 2 MHz
STEPRATE2	EQU 2		;20ms, 10ms if 179x and 2 MHz, 2ms if WD1772
STEPRATE3	EQU 3		;30ms, 15ms if 179x and 2 MHz, 3ms if WD1772
;
;	TYPE I AND TYPE II COMMANDS LOW NIBBLE
;	1770/1772 only
SPINWAIT	EQU 00000000B	;1770/1772: Enable spin up sequence
NOWAITMTR	EQU 00001000B	;1770/1772: Disable spin up sequence
;
;	TYPE II COMMANDS LOW NIBBLE
;	(F1)
SIDECMP	EQU	00000010B	;1791/1793: Side Select Compare Enabled \ 1795/1797: Update SSO to 1 \ 1773: Enable Side Compare
;
;	(F2) - Read Sector and Write Sector commands only
SIDESEL	EQU	00001000B	;1791/1793/1773: Side Select Compare for Side 1 \ 1795/1797: Interpret Sector Len Field 00=128, 01=256, 10=512,  11=1024
;		EQU	00000000B	;1791/1793/1773: Side Select Compare for Side 0 \ 1795/1797: Interpret Sector Len Field 00=256, 01=512, 10=1024, 11=128
;
;	TYPE II AND TYPE III COMMANDS LOW NIBBLE
;
SETTLE	EQU	00000100B	;179x: Add 15ms delay (2MHz)
WRPCOMP	EQU	00000010B	;1770/1772/1773 Write Sector and Write Track commands only: Enable Write Precompensation
;
;
		IF SALLYBUILD
HLOAD		EQU	SPINWAIT	; Sally2
STEPRATE	EQU	STEPRATE1	; Sally2 - 12ms step rate
		ELSE
HLOAD		EQU	00001000B	; ATR 8000 original
STEPRATE	EQU	STEPRATE3	; ATR 8000 original - 15ms step rate
		ENDIF
;
;
RIDCMD	EQU	11000000B	;READ ID COMMAND
IF SALLYBUILD
RDCMD	EQU	10000000B	;READ COMMAND
WRTCMD	EQU	10100000B	;WRITE COMMAND
ELSE
RDCMD	EQU	10000000B+HLOAD	;READ COMMAND
WRTCMD	EQU	10100000B+HLOAD	;WRITE COMMAND
ENDIF
FINCMD	EQU	11010000B	;FORCE INTERRUPT COMMAND
SKCMD	EQU	00010000B	;SEEK COMMAND
RSTCMD	EQU	00000000B	;RESTORE COMMAND
STEPOUT	EQU	01100000B	;STEP OUT COMMAND
STEPIN	EQU	01000000B	;STEP IN COMMAND
RDTRK	EQU	11100000B	;READ TRACK COMMAND
WRTRK	EQU	11110000B	;WRITE TRACK COMMAND
RDTKDLY	EQU	RDTRK+100B	;WRITE TRACK COMMAND with 15ms settling delay (179x/1773: 30ms if 1MHz)
WRTKDLY	EQU	WRTRK+100B	;READ TRACK COMMAND with 15ms settling delay (179x/1773: 30ms if 1MHz)
;
;
; Drive control LATCH (U24)
;
DRVSEL1		EQU 00000001B	; 1 = select drive 1
DRVSEL2		EQU 00000010B	; 1 = select drive 2
DRVSEL3		EQU 00000100B	; 1 = select drive 3
DRVSEL4		EQU 00001000B	; 1 = select drive 4
FDCRESET	EQU 00010000B	; 1 = Put FDC chip in reset, 0 = Release FDC chip from reset
FDCSIDE		EQU 00100000B	; Side select pin on floppy connector
FBS			EQU 01000000B	; 0 = B, 1 = S
FDENSITY	EQU 10000000B	; 0 = Double, 1 = Single
;
;
;
NMIVEC	EQU	0066H
;
;
;
;
;	... DATA STRUCTURE FOR DISK I/O CONTROL BLOCK ...
;
DSKOP	EQU	0		;DISK OPERATION CODE
DSKDRV	EQU	1		;DRIVE# (WITH SIDE# IN BIT 7)
DSKTRK	EQU	2		;TRACK#
DSKSEC	EQU	3		;SECTOR#
DSKPTR	EQU	4		;READ/WRITE POINTER
DSKAUX	EQU	6		;AUXILLIARY PARAMETERS (2 BYTES)
DSKSTS	EQU	8		;OPERATION COMPLETION STATUS
;
;
;	... DISK DRIVER OPERATION CODE DEFINITIONS ...
;
TSTRDY	EQU	0		;SELECT DRIVE AND TEST READY
GETSEC	EQU	1		;READ SECTOR
PUTSEC	EQU	2		;WRITE SECTOR
GETID	EQU	3		;READ ID MARK
;
;
;
DISKDVR:
	CALL	STOPTMR		;KILL DISK TIMER INTERRUPT FROM CTC3
	LD	A,(IX+DSKOP)
	OR	A
	JR	Z,TESTDRV	;JUMP IF TEST READY OPERATION
	LD	B,RDCMD
	DEC	A
	JR	Z,SETSSO	;JUMP IF DISK READ OPERATION
	LD	B,WRTCMD
	DEC	A
	JR	Z,SETSSO	;JUMP IF DISK WRITE OPERATION
	DEC	A
	JR	Z,READID	;JUMP IF DISK ID READ OPERATION
	LD	(IX+DSKSTS),255	;ELSE SET ALL ERROR BITS AND RETURN

ACTIVON:
	DI
	LD	A, CTC_D7_INT_EN + CTC_D6_MODE_TIM + CTC_D5_PRESC256 + CTC_D2_TCNEXT + CTC_D1_SW_RST + CTC_D0_CONTROL
	OUT	(CTC3),A	;PUT CTC3 IN TIMER MODE, PRESCALE 256
	XOR	A			;TIME CONSTANT OF 0 WHICH MEANS 256
	OUT	(CTC3),A	;COUNT MOD 256
	DEC	A
	LD	(DRVTMR),A	;STOP DRIVES AFTER 255 INTERRUPTS
	LD	HL,ACTIVTY
	LD	(CTCVEC+6),HL	;SET VECTOR TO ACTIVITY-CHECK ROUTINE
	EI
	RET
;
;
;
ACTIVTY:
	PUSH	AF
	LD	A,(DRVTMR)
	DEC	A
	LD	(DRVTMR),A
	JR	NZ,ACTV2	;EXIT IF 4 SECONDS NOT ELAPSED

	call	shutdown
	LD	A, CTC_D7_INT_DIS + CTC_D6_MODE_TIM + CTC_D5_PRESC256 + CTC_D0_CONTROL
	OUT	(CTC3),A	;RESET INTERRUPT BUT KEEP COUNTER GOING
	LD	(DRVOFF),A	;SET 'DRVOFF' FLAG TO NON-ZERO VALUE

ACTV2:	POP	AF
	EI
	RETI
;
;
;
shutdown:
IF SALLYBUILD
	CALL	SalyResetFDC
	LD	A, 040h
ELSE
	IN	A,(TRKREG)
	OUT	(DATREG),A
	LD	A,SKCMD
	OUT	(CMDREG),A	;DUMMY SEEK TO UNLOAD THE HEADS
	LD	A,(OUTCPY)
	AND	11110000B	;DESELECT ALL 4 DRIVES
ENDIF
	OUT	(LATCH),A
	ret
	
;
;
;
;
;
;	... DRIVE READY/STATUS TEST FUNCTION ...
;
;
TESTDRV:
	CALL	SELECT		;SELECT DRIVE FOR SPIN/STATUS CHECK	
	BIT	7,A
	JR	Z,TDRV2		;JUMP IF DRIVE READY INDICATED

	LD	HL,PERIOD	;ELSE SET PERIOD TO ZERO
	LD	(HL),0

TDRV2:	LD	(IX+DSKSTS),A	;RETURN TYPE 1 STATUS IN 'DSKSTS'
	LD	A,(OUTCPY)
	LD	(IX+DSKAUX),A	;RETURN CONTROL BITS IN AUX BYTE #1
	LD	A,(PERIOD)
	LD	(IX+DSKAUX+1),A	;RETURN PERIOD IN AUX BYTE #2
	CALL	ACTIVON		;START DISK ACTIVITY MONITOR AGAIN
	RET
;
;
;
;	... READ ID MARK FUNCTION ...
;
READID:
	LD	(IX+DSKAUX),6
	LD	(IX+DSKAUX+1),0
	LD	B,RIDCMD
	CALL	DISK		;READ 6 BYTE ID RECORD
	LD	A,(OUTCPY)
	LD	(IX+DSKAUX),A	;RETURN DRIVE CONTROL LATCH BYTE
	RET
;
;
;
;	... SECTOR READ/WRITE FUNCTION ...
;
SETSSO:
IF SALLYBUILD <> 1
	BIT	7,(IX+DSKDRV)	;TEST SIDE# BIT IN DRIVE PARAM
	JR	Z,DISK
	SET	1,B		;SET 'SSO' CONTROL BIT IN 1797 CMD
ENDIF
DISK:
	LD	A,B
	LD	(CMDBYT),A	;STORE 1797 COMMAND PASSED IN B
	CALL	SELECT		;SELECT DRIVE/SIDE FOR DISK OPERATION
	BIT	7,A
	JR	NZ,DISKX	;EXIT IF NOT READY

	LD	A,(TRACK)
	CP	255
	JR	Z,DISK2
	CP	(IX+DSKTRK)	;TEST IF ALREADY AT DESIRED TRACK
	JR	Z,DISK3		;SKIP SEEK PART IF SO

DISK2:	CALL	SEEKTRK		;GO LOOKING FOR TRACK# IN IOCB
	JR	NZ,DISKX	;EXIT IF HEAD POSITIONING ERROR

DISK3:	LD	A,(CTCVEC+2)
	INC	A		;LOOP TILL TX CTC TURNS ITSELF OFF
	JR	NZ,DISK3	;(INTERRUPT VECTOR LSB SET=FFH)
SalyDISK3:
	DI
	LD	A, CTC_D1_SW_RST + CTC_D0_CONTROL	; SOFTWARE RESET CTC0
	OUT	(CTC0),A	;DISABLE RX INTERRUPT FROM CTC0
	LD	A, CTC_D6_MODE_TIM + CTC_D5_PRESC256 + CTC_D2_TCNEXT + CTC_D1_SW_RST + CTC_D0_CONTROL	; SET PRESCALER TO 256 AND SOFTWARE RESET
	OUT	(CTC2),A	;DISABLE CTC2 AND ALSO INIT FOR CLOCK SOURCE FOR WATCHDOG TIMER
	LD	A,61		;SET TIME COUNTER TO 61, about 3.9ms
	OUT	(CTC2),A
	LD	HL,WATCHDOG	;STORE NEW CTC3 VECTOR FOR SAFETY
	LD	(CTCVEC+6),HL

	LD	A,(RWMAX)
	LD	(RWTRY),A	;SET READ/WRITE RETRY COUNT
DISK4:	LD	A,(IX+DSKSEC)	;OUTPUT SECTOR NUMBER FOR READ/WRITE
	OUT	(SECREG),A
	LD	A,(IX+DSKTRK)
	OUT	(TRKREG),A	;DITTO FOR TRACK NUMBER
	LD	A,(CMDBYT)
	OUT	(CMDREG),A	;START 1791 WORKING ON W/R COMMAND
	CALL	RWDISK		;DO HALT/NMI DISK DATA TRANSFER
	JR	Z,DISKX		;EXIT IF NO DISK ERRORS
	PUSH	AF
	CALL	RECOVER		;DO READ/WRITE ERROR RECOVERY ROUTINE
	POP	BC
	JR	NZ,DISK5	;SKIP RETRY IF IRRECOVERABLE ERROR
	LD	HL,RWTRY
	DEC	(HL)
	JR	NZ,DISK4	;ELSE DECREMENT RETRY COUNT TILL=0
DISK5:	LD	A,B		;THEN LOAD A WITH ERROR STATUS
DISKX:	LD	(IX+DSKSTS),A	;SAVE COMPLETION STATUS CARRIED IN ACC
	CALL	RENEW		;RESTART ATARI AND RS232 INTERRUPTS
	CALL	ACTIVON		;START DISK ACTIVITY TIMER
	RET
;
;
;
;	... SELECT DRIVE# PASSED @IX AND RETURN TYPE 1 STATUS ...
;
SELECT:
	LD	A,(IX+DSKDRV)
	RES	7,A		;CLEAR SIDE SELECT BIT FROM DRIVE#
	CP	4
	JR	NC,SELX		;EXIT IF INVALID DRIVE NUMBER

	LD	B,0
	LD	C,A		;LOAD BC WITH NEW DRIVE# TO BE SELECTED
	LD	HL,UNIT
	SUB	(HL)		;COMPARE NEW AND OLD SELECT CODES AND
	PUSH	AF		; SAVE RESULT STATUS ON STACK
	LD	D,B
	LD	E,(HL)		;LOAD DE WITH LAST SELECTED DRIVE#
	LD	(HL),C		;THEN STORE NEW UNIT# FROM C

	LD	HL,DRVTAB
	ADD	HL,DE		;INDEX INTO TABLE BY CURRENT DRIVE#
	LD	A,(TRACK)
	LD	(HL),A		;REMEMBER CURENT TRACK NUMBER
	LD	E,4
	ADD	HL,DE		;NOW INDEX TO CONTROL BYTE FOR UNIT
	LD	A,(OUTCPY)
	LD	(HL),A		;REMEMBER CURRENT DENSITY/TYPE

	LD	HL,DRVTAB
	ADD	HL,BC		;INDEX INTO TABLE BY NEW DRIVE#
	LD	A,(HL)
	LD	(TRACK),A	;STORE CURRENT (ASSUMED) HEAD POSITION
	ADD	HL,DE
	POP	DE		;POP UNIT# COMPARE RESULT INTO D
	LD	A,(HL)		;GET CURRENT SELECT/TYPE BITS FOR DRIVE
	OR	A
	JR	NZ,SEL5		;JUMP IF NOT AN INITIAL DRIVE SELECT
;
;	ARRIVE HERE ON INITIAL DRIVE SELECT
;
	LD	HL,SELTAB
	ADD	HL,BC		;ELSE INDEX INTO TABLE OF SELECT BITS
	LD	A,(HL)
	OUT	(LATCH),A	;OUTPUT NEW DRIVE SELECTS
	PUSH	AF
	CALL	SPIN		;NOW SPIN UP TO TEST READY
	POP	BC
	CP	222		;ERROR IF SLOWER THAN 222 MS
	JR	NC,SELX

	SET	6,B
	CP	181		;MINI FLOPPY IF BETWEEN 222 AND 181 MS
	JR	NC,SEL4

	RES	6,B
	CP	153		;BIG FLOPPY IF BETWEEN 181 AND 153 MS
	JR	C,SELX

SEL4:	LD	A,B		;GET CONTROL BITS INTO A
	LD	D,0		;SET D=0 TO DISABLE HEAD LOAD DELAY
;
;	ARRIVE HERE WITH DENSITY/TYPE/SELECT BITS IN ACC
;	
SEL5:	RES	5,A		;RESET SIDE SELECT BIT UNCONDITIONALLY
	BIT	7,(IX+DSKDRV)
	JR	Z,SEL5A		;JUMP IF SELECTING SIDE# ZERO
	SET	5,A		;ELSE SET SIDE SELECT BIT IN ACC
SEL5A:	OUT	(LATCH),A
	LD	(OUTCPY),A	;OUTPUT AND SAVE NEW PATTERN
	INC	D
	DEC	D
	CALL	NZ,HLDWAIT	;DO HEAD LOAD DELAY IF NEW DRIVE SELECT
IF SALLYBUILD
	IN	A,(TRKREG)	;get status
	OUT	(DATREG),A
	LD	A,SKCMD
	CALL	CMDOUT
ENDIF
	CALL	FORCE
	BIT	5,A		;TEST 1797 HEAD-LOAD STATUS
	RET	NZ		;EXIT IF LOADED AND MOTORS ON
	
	CALL	SPIN		;ELSE LET THINGS SPIN A BIT
	OR	A		;TEST PERIOD AFTER RE-SPINUP
KLUDGE:	JR	Z,SELX		;ERROR IF DISK REFUSES TO TURN
	
IF SALLYBUILD
	JP	FORCE		;ELSE RETURN TYPE 1 STATUS THIS TIME
ELSE
	CALL	FORCE		;ELSE RETURN TYPE 1 STATUS THIS TIME
	RET
ENDIF
;
;	ARRIVE HERE IF DRIVE CANNOT BE SELECTED AT ALL
;
SELX:	XOR	A		;TURN OFF EVERYTHING
IF SALLYBUILD
	LD	(OUTCPY),A
	LD	a, 040h		;TURN OFF -> 8Mhz
	OUT	(LATCH),A
	rlca			;40h --> 80h
ELSE
	OUT	(LATCH),A
	LD	(OUTCPY),A
	LD	A,10000000B
ENDIF
	OR	A		;RETURN WITH NOT-READY ERROR
	RET
;
;
;
;
;
SELTAB:	DEFB	00000001B
	DEFB	00000010B
	DEFB	00000100B
	DEFB	00001000B
;
;
;
SPIN:
IF SALLYBUILD
	CALL	STARTMR		;THEN RE-PROGRAM CTC1 FOR TIMER
	LD	A, FINCMD
	CALL	CMDOUT
ELSE
	XOR	A
	OUT	(INDXSET),A
	INC	A
	OUT	(INDXCLR),A	;SET TO ENABLE NORMAL INDEX PULSES
	IN	A,(TRKREG)
	OUT	(DATREG),A
	LD	A,SKCMD+HLOAD
	OUT	(CMDREG),A	;DO DUMMY SEEK TO START THE MOTORS
	CALL	STARTMR		;THEN RE-PROGRAM CTC1 FOR TIMER
	CALL	FORCE
ENDIF
	LD	C,A		;SAVE CURRENT TYPE 1 DISK STATUS
	LD	B,6		;SET FOR 6 DISK REVOLUTIONS
	LD	HL,0
	LD	(TICKS),HL	;RESET MILLISECOND COUNTER FOR IRQ
SPIN2:	LD	DE,(TICKS)
	CALL	EDGE		;WAIT FOR INDEX INPUT TO CHANGE
	JR	C,SPIN3		;ABORT IF TIMEOUT
	CALL	EDGE		;WAIT FOR CHANGE BACK AGAIN
	JR	C,SPIN3
	DJNZ	SPIN2		;LET 6 REVOLUTIONS PASS

	LD	HL,(TICKS)	;READ TIME AT END OF REVOLUTION
	OR	A
	SBC	HL,DE		;COMPUTE INDEX PERIOD IN MILLISECONDS

IF SALLYBUILD
SPIN5:
	in	a, (STSREG)
	bit	7, a
	jr	nz, SPIN5
SPIN6:	CALL	STOPTMR		;KILL INTERRUPT FROM CTC3

ELSE

SPIN3:	CALL	STOPTMR		;KILL INTERRUPT FROM CTC3
	XOR	A
	OUT	(INDXCLR),A
	INC	A
	OUT	(INDXSET),A	;DISABLE INDEX PULSES AFTER THIS
ENDIF

	LD	A,L
	INC	H
	DEC	H
	JR	Z,SPIN4		;A HOLDS VALID PERIOD IF H=0
	LD	A,255
SPIN4:	LD	(PERIOD),A
	RET

IF SALLYBUILD
SPIN3:	CALL	SalyResetFDC
	JR	SPIN6
ENDIF
;
;
;
EDGE:
IF SALLYBUILD
	IN	a, (STSREG)
ELSE
	CALL	FORCE		;GET 1797 TYPE 1 STATUS
ENDIF
	XOR	C
	AND	00000010B	;CHECK FOR CHANGE IN INDEX BIT
	JR	NZ,EDGE2	;EXIT IF BIT CHANGES

	LD	A,(TICKS+1)
	CP	HIGH 2048	;ELSE CHECK TIME ACCUMULATED IN 'TICKS'
	JR	C,EDGE		;KEEP LOOPING TILL 2 SECONDS PASS

	SCF
	RET			;THEN RETURN WITH CARRY=1
;
EDGE2:	LD	A,C
	CPL			;FLIP INDEX STATE HELD IN C
	LD	C,A
	RET			;RETURN WITH CARRY=0
;
;
;
;
;	... SEEK TRACK# IN (IX+DSKTRK) FROM TRACK# IN (TRACK) ...
;
SEEKTRK:
	LD	A,(TRACK)
	CP	255
	JR	NZ,SEEK1	;JUMP IF HEAD POSITION IS KNOWN

	CALL	RESTORE		;ELSE DO SLOW RESTORE TO RECALIBRATE
	JR	NZ,SEEKX	;EXIT WITH PERMANENT ERROR IF FAILURE

SEEK1:	LD	B,1
	CALL	SEEK		;FIRST SEEK (IX+DSKTRK) WITH NO RETRIES
	RET	Z		;EXIT IF WE GOT TO THE DESIRED TRACK
	JR	NC,SEEK2	;JUMP IF WE LANDED ON SOME OTHER TRACK

	CALL	RESTORE		;ELSE RECALIBRATE BEFORE TRYING AGAIN
	JR	NZ,SEEKX	;EXIT IF TRACK ZERO NOT FOUND

SEEK2:	LD	B,2
	CALL	SEEK		;NOW SEEK WITH TWO TRIES
	RET	Z		;EXIT IF SUCCESSFUL THIS TIME
	JR	C,SEEKX		;EXIT IF NO ID MARK COULD BE FOUND

	LD	HL,100
	CALL	WAIT		;DELAY TO LET THE STEPPER RELAX ITSELF
	LD	HL,RATES
	LD	A,(UNIT)
	ADD	A,L
	LD	L,A		;INDEX INTO TABLE TO DRIVE'S STEP RATE
	INC	(HL)		; AND MAKE STEP RATE ONE NOTCH SLOWER
	LD	A,(HL)
	AND	00000011B	;CHECK FOR ROLL AROUND IN LOWER 2 BITS
	JR	NZ,SEEK2	;REPEAT IF STEP RATE BITS WERE NOT=3

	DEC	(HL)		;ELSE RESTORE FROM ROLL AROUND
SEEKX:	LD	A,255
	LD	(TRACK),A	;FLAG TRACK POSITION AS UNKNOWN
	LD	A,00010000B	;SET SEEK ERROR BIT IN STATUS WORD
	OR	A
	RET			;RETURN WITH RNF ERROR STATUS IN A
;
;
;
;
		IF SALLYBUILD
SalyResetFDC:
		ELSE
RESTORE:
		ENDIF
	LD	A,(OUTCPY)
	SET	4,A
	OUT	(LATCH),A	;TWANG THE DISK CONTROLLER RESET PIN
	LD	B,15
	DJNZ	$		;HOLD RESET 50 MICROSECONDS
	RES	4,A
	OUT	(LATCH),A

IF SALLYBUILD
	DJNZ	$
	ret

RESTORE:
	CALL	SalyResetFDC

ELSE
	LD	B,0
	DJNZ	$
	CALL	FORCE		;THEN FORCE CLEAR THE BEAST
ENDIF

	LD	A,RSTCMD+HLOAD+STEPRATE
	CALL	TYP1CMD		;DO RESTORE AT SLOWEST STEP RATE
	XOR	00000100B
IF SALLYBUILD
	AND	00000100B
ELSE
	AND	10000100B
ENDIF
	RET			;RETURN WITH ACC=0 IF HOME
;
;
;
SEEK:
	PUSH	BC		;SAVE LOOPCOUNT IN B
	LD	A,(TRACK)
	LD	B,A		;LOAD B WITH CURRENT TRACK POSITION
	LD	C,(IX+DSKTRK)	;LOAD C WITH DESTINATION TRACK#
	CALL	STEP		;HAVE A GO AT STEPPING
	CALL	VERIFY		;VERIFY HEAD POSITION WITH READ-ID
	POP	BC
	SCF
	RET	NZ		;EXIT WITH CARRY SET IF READ-ID FAILS

	IN	A,(SECREG)
	LD	(TRACK),A	;STORE ACTUAL TRACK# FROM ID MARK
	SUB	(IX+DSKTRK)	;COMPARE IF WE GOT THERE THIS TIME
	RET	Z		;EXIT WITH ACC=0 IF TRACK# VERIFIED

	DJNZ	SEEK		;DO PRESCRIBED NUMBER OF SEEK RETRIES

	OR	A
	RET			;RETURN WITH CARRY AND ZERO FLAGS CLEAR
;
;
;
;	STEP FROM TRACK# IN B TOWARDS TRACK# IN C
;
STEP:
	LD	A,B
	OUT	(TRKREG),A	;STARTING TRACK# TO TRACK REGISTER
	LD	A,C
	OUT	(DATREG),A	;DESTINATION TRACK# TO DATA REGISTER
	LD	HL,RATES
	LD	A,(UNIT)
	ADD	A,L
	LD	L,A		;INDEX INTO STEP RATE TABLE FOR DRIVE
	LD	A,(HL)
IF SALLYBUILD
	ld	a, SKCMD+HLOAD+STEPRATE
ELSE
	AND	00000011B	;EXTRACT LOWER 2 BITS FOR STEP RATE
	OR	SKCMD+HLOAD	;MERGE WITH SEEK COMAND
ENDIF
	CALL	TYP1CMD		;DO SEEK WITH SPECIFIED STEP RATE
	LD	A,(HL)
	AND	11111100B	;EXTRACT UPPER 6 BITS FOR SETTLE TIME
	LD	H,0
	LD	L,A
	CALL	WAIT		;4..256 MILLISECOND HEAD SETTLING DELAY
	RET
;
;
;
;
VERIFY:
	LD	A,RIDCMD
	CALL	TYP2CMD		;READ NEXT ID MARK TO VERIFY SEEK
IF SALLYBUILD
	AND	00011000B	;WD1772, bit 7 reset by TYP2CMD!
ELSE
	AND	10011000B
ENDIF
	RET	Z		;EXIT IF ID MARK READ OK

	LD	A,(OUTCPY)
	XOR	10000000B	;COMPLIMENT DENSITY BIT OF DRIVE TYPE
	LD	(OUTCPY),A
	OUT	(LATCH),A
	LD	HL,50
	CALL	WAIT		;ALLOW 50 MS DELAY AFTER CLOCK SWITCH
	LD	A,RIDCMD
	CALL	TYP2CMD		;TRY AGAIN IN NEW DENSITY
IF SALLYBUILD
	AND	00011000B
ELSE
	AND	10011000B
ENDIF
	RET			;A=0 IF AN ID MARK WAS FOUND
;
;
;
;
;
;
RWDISK:				;A=1797 TYPE 2 COMMAND BYTE
	LD	HL,(NMIVEC)
	PUSH	HL
	LD	HL,(NMIVEC+2)
	PUSH	HL		;SAVE 4 BYTES AT NMI VECTOR
	LD	HL,0A2EDH	;LOAD HL WITH 'INI' OPCODE
	BIT	5,A		;TEST IF READ OR WRITE BEING DONE
	JR	Z,RW2		;JUMP IF COMMAND IS A READ
	INC	H		;ELSE TRANSFORM 'INI' INTO 'OUTI'
RW2:	LD	(NMIVEC),HL
	LD	HL,NMIVEC+2
	LD	(HL),0C9H	;STORE 'RET' OPCODE AFTER INI/OUTI
	DI
	LD	A,CTC_D7_INT_EN + CTC_D6_MODE_CNT + CTC_D2_TCNEXT + CTC_D1_SW_RST + CTC_D0_CONTROL
	OUT	(CTC3),A	;ARM CTC3 FOR COUNTER MODE INTERRUPT
	XOR	A		;TIME CONSTANT OF 0 WHICH MEANS 256
	OUT	(CTC3),A	;COUNT 256 PULSES FROM CTC3
	EI
	LD	L,(IX+DSKPTR)	;HL=DISK READ/WRITE DATA POINTER
	LD	H,(IX+DSKPTR+1)
	LD	B,(IX+DSKAUX)	;B=SECTOR LENGTH COUNT (LSB)
	LD	C,DATREG	;C=DISK DATA PORT#
	LD	A,(IX+DSKAUX+1)
	SRL	A
	JR	Z,RW256		;JUMP IF BLOCKSIZE <= 256 BYTES
	SRL	A
	JR	Z,RW512		;JUMP IF BLOCKSIZE <= 512 BYTES
RW1024:	HALT
	JR	NZ,$-1
	HALT
	JR	NZ,$-1
RW512:	HALT
	JR	NZ,$-1
RW256:	HALT
	JR	NZ,$-1
RWBUSY:	IN	A,(STSREG)
	BIT	0,A
	JR	NZ,RWBUSY	;LOOP TILL 1797 BUSY BIT GOES AWAY
	ld	b,a
	call	stoptmr
	ld	a,b
RWEXIT:	POP	HL
	LD	(NMIVEC+2),HL
	POP	HL
	LD	(NMIVEC),HL	;RESTORE CODE AT NMI
IF SALLYBUILD
	AND	01111101B	;MASK FOR DISK ERRORS
ELSE
	AND	11111101B	;MASK FOR DISK ERRORS
ENDIF
	RET			;RETURN WITH DISK ERROR FLAGS SET
;
;
;
;
RECOVER:
	LD	B,A
	AND	11100111B	;MASK OFF ALL BUT RNF/CRC ERROR BITS
	JR	Z,RECOV1	;JUMP IF ONE OF THOSE TWO WERE SET

	PUSH	AF
	CALL	FORCE		;RESET ERROR FLAGS IN 179X STATUS REG
	POP	AF
IF SALLYBUILD
	AND	01100001B	;CLEAR BITS ASSOCIATED WITH LOST DATA
ELSE
	AND	11100001B	;CLEAR BITS ASSOCIATED WITH LOST DATA
ENDIF
	RET			;RETURN WITH ACC=0 IF RETRY TO BE DONE
;
RECOV1:	BIT	4,B
	JR	NZ,RECOV3	;JUMP IF RECORD-NOT-FOUND ERROR
;
;	ARRIVE HERE IF BAD CRC ERROR
;
RECOV2:	LD	A,(RWMAX)
	LD	HL,RWTRY
	SUB	(HL)		;COMPUTE HOW MANY RETRYS HAVE BEEN DONE
	RET	Z		;EXIT IF FIRST RETRY

	LD	A,(TRACK)	;ELSE PREPARE TO WIGGLE BACK AND FORTH
	LD	B,A		; TO AN ADJACENT TRACK TO RE-CALIBRATE
	OR	A		; AND REMOVE POSSIBLE MEDIA CONTAMINANT
	JR	NZ,RCOV2A
	LD	C, 1		;STEP TO TRACK#1 IF ON TRACK# 0
	JR	RCOV2B
;
RCOV2A:	DEC	A		;STEP TO NEXT OUTER TRACK
	LD	C,A
RCOV2B:	PUSH	BC
	CALL	STEP		;STEP HEAD TO ADJACENT TRACK
	POP	DE
	LD	B,E		;EXCHANGE CONTENTS OF B AND C
	LD	C,D
	CALL	STEP		;STEP BACK TO ORIGINAL TRACK
	call	verify
	ret			;allow retry successful read id
;
;	ARRIVE HERE IF RECORD-NOT-FOUND ERROR
;
recov3:	call	verify		;read an id mark to verify position
	JR	NZ,RCOV4A	;RECALIBRATE IF VERIFY FAILS

	IN	A,(SECREG)	;LOAD A WITH CURENT TRACK# UNDER HEAD
	CP	(IX+DSKTRK)
	JR	NZ,RCOV4B	;JUMP IF NOT ON CORRECT TRACK
;
;	ARRIVE HERE IF ON CORRECT TRACK
;
	ld	a,(rwmax)
	ld	hl,rwtry
	sub	(hl)		;test if this is first retry after rnf error
	ret	z

	ld	a,00010000b
	ret			;indicate permanent rnf error
;
;	ARRIVE HERE IF HEAD POSITION IS INCORRECT
;
RCOV4A:	LD	A,255		;SET A TO FORCE RESTORE BEFORE SEEK
RCOV4B:	LD	(TRACK),A
	CALL	SEEKTRK		;SEEK TRACK# SPECIFIED IN IOCB
	RET
;
;
;
;
;	EXECUTE TYPE 2 COMMAND (READ/WRITE/READ ID) WITH TIMEOUT
;
TYP2CMD:
	CALL	CMDOUT		;ISSUE COMMAND
	PUSH	BC
	LD	BC,6250		;500,000/80 FOR ONE HALF SECOND DELAY
	JR	TPCMD2
;
;
;	EXECUTE TYPE 1 COMMAND (SEEK/STEP/RESTORE)
;
TYP1CMD:
	CALL	CMDOUT
	PUSH	BC
	LD	BC,37500	;3,000,000/80 FOR 3 SECONDS DELAY
TPCMD2:	IN	A,(STSREG)
	BIT	0,A
	JR	Z,TPCMD3	;EXIT IF BUSY BIT GOES AWAY

	CALL	CMDT1		;DELAY 56 MICROSECONDS
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,TPCMD2	;LOOP TAKES 80 MICROSECONDS

	LD	A,00010000B

TPCMD3:
IF SALLYBUILD
	res	7, a		;reset WD1797: drive not ready, WD1772: motor on!
ELSE
	LD	B,A
	CALL	FORCE
	LD	A,B
ENDIF
	POP	BC
	RET
;
;
;
CMDOUT:
	OUT	(CMDREG),A	;OUTPUT DISK CONTROLLER COMMAND BYTE
CMDT1:	LD	A,14	
CMDT2:	DEC	A
	JR	NZ,CMDT2	;DELAY 56 MICROSECONDS
	RET
;
;
;
;
FORCE:
IF SALLYBUILD
	IN	a, (TRKREG)
	OUT	(DATREG), a
	LD	A,SKCMD+NOWAITMTR	;disable spinup HLOAD
	jr	TYP1CMD		;CLEAR 179X AND LATCH READY/HLD/TK0 ETC
ELSE
	LD	A,FINCMD	;LOAD FORCE-INTERRUPT-IMMEDIATE CMD
	CALL	CMDOUT		;CLEAR 179X AND LATCH READY/HLD/TK0 ETC
	IN	A,(STSREG)	;READ STATUS REGISTER CONTENTS
	RET
ENDIF
;
;
;
;
;
HLDWAIT:
	LD	HL,(HLDTIM)	;LOAD HL WITH HEAD LOAD DELAY
	LD	H,0		;RANGE 1..256 MILLISECONDS

WAIT:	XOR	A
WAIT2:	DEC	A
	JR	NZ,WAIT2	;DELAY 1 MILLISECOND
	DEC	HL
	LD	A,H
	OR	L
	JR	NZ,WAIT		;LOOP UNTIL HL=0
	RET
;
;
;
;	... CTC INTERRUPT CONTROL ROUTINES FOR DISK HANDLER ...
;
;
;
WATCHDOG:
	LD	A,FINCMD
	OUT	(CMDREG),A	;ABORT DISK CONTROLLER OPERATION
	LD	A,00000001B
	OUT	(CTC3),A	;RESET INTERRUPT FROM CTC3
	LD	HL,RWEXIT
	EX	(SP),HL		;TOSS RETURN ADDRESS AND PLANT FAKE ONE
	LD	A,00010000B
	OR	A		;INDICATE RECORD-NOT-FOUND ERROR
	EI
	RETI			;INSURE CTC IRQ LOGIC GETS RESTORED
;
;
;
;
;
;	... MILLISECOND TIMER INTERRUPT ROUTINES ...
;
;
STARTMR:
	DI
	LD	A,10000111B
	OUT	(CTC3),A
	LD	A,250
	OUT	(CTC3),A
	LD	HL,TMRIRQ
	LD	(CTCVEC+6),HL
	EI
	RET
;
;
;
STOPTMR:
	DI
	LD	A,00000001B
	OUT	(CTC3),A
	EI
	RET
;
;
;
TMRIRQ:
	PUSH	HL
	EI
	LD	HL,(TICKS)
	INC	HL		;BUMP FREE RUNING MILLISECOND COUNTER
	LD	(TICKS),HL
	POP	HL
	RETI
;
;
IF SALLYBUILD
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
ENDIF
